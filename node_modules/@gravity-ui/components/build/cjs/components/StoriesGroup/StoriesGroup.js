"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoriesGroup = void 0;
const react_1 = __importDefault(require("react"));
const uikit_1 = require("@gravity-ui/uikit");
const StoriesLayout_1 = require("../Stories/components/StoriesLayout/StoriesLayout");
const cn_1 = require("../utils/cn");
const components_1 = require("./components");
require("./StoriesGroup.css");
const DEFAULT_MAX_SLIDER_ITEMS_COUNT = 12;
const b = (0, cn_1.block)('stories-group');
// eslint-disable-next-line complexity
const StoriesGroup = ({ open, groups, onItemSelect, disableOutsideClick = true, initialStoryIndex = [0, 0], maxSliderItemsCount = DEFAULT_MAX_SLIDER_ITEMS_COUNT, onClose, }) => {
    const [[groupIndex, itemIndex], setStoryIndex] = react_1.default.useState(initialStoryIndex);
    const handleClose = react_1.default.useCallback((event, reason) => {
        onClose === null || onClose === void 0 ? void 0 : onClose(event, reason);
    }, [onClose]);
    const handleButtonClose = react_1.default.useCallback((event) => {
        handleClose(event, 'closeButtonClick');
    }, [handleClose]);
    const handleGotoPrevious = react_1.default.useCallback(() => {
        setStoryIndex((prevState) => {
            const [currentGroupIndex, currentItemIndex] = prevState;
            if (currentItemIndex > 0) {
                const newState = [currentGroupIndex, currentItemIndex - 1];
                onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect(newState, false);
                return newState;
            }
            // try to find previous valid group
            for (let i = currentGroupIndex - 1; i >= 0; --i) {
                if (groups[i].items.length !== 0) {
                    const newState = [i, groups[i].items.length - 1];
                    onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect(newState, false);
                    return newState;
                }
            }
            return prevState;
        });
    }, [groups, onItemSelect]);
    const handleGotoNext = react_1.default.useCallback(() => {
        setStoryIndex((prevState) => {
            var _a;
            const [currentGroupIndex, currentItemIndex] = prevState;
            if (currentItemIndex < ((_a = groups[currentGroupIndex]) === null || _a === void 0 ? void 0 : _a.items.length) - 1) {
                const newState = [currentGroupIndex, currentItemIndex + 1];
                onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect(newState, false);
                return newState;
            }
            // try to find next valid group
            for (let i = currentGroupIndex + 1; i < groups.length; ++i) {
                if (groups[i].items.length !== 0) {
                    const newState = [i, 0];
                    onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect(newState, false);
                    return newState;
                }
            }
            return prevState;
        });
    }, [groups, onItemSelect]);
    const onGroupSelect = react_1.default.useCallback((newGroupIndex) => {
        setStoryIndex([newGroupIndex, 0]);
        onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect([newGroupIndex, 0], true);
    }, [onItemSelect]);
    if (groups.length === 0) {
        return null;
    }
    const currentGroup = groups[groupIndex];
    const currentItems = (currentGroup === null || currentGroup === void 0 ? void 0 : currentGroup.items) || [];
    // case when groups has changed and indexs has ceased to be valid
    if (currentGroup === undefined || currentItems[itemIndex] === undefined) {
        if (groups[initialStoryIndex[0]] &&
            groups[initialStoryIndex[0]].items[initialStoryIndex[1]]) {
            setStoryIndex(initialStoryIndex);
        }
        else {
            // try to find first valid index
            for (let i = 0; i < groups.length; ++i) {
                if (groups[i] && groups[i].items.length !== 0) {
                    setStoryIndex([i, 0]);
                    break;
                }
            }
        }
        return null;
    }
    const indexType = (groups.length === 1 && currentItems.length === 1 && StoriesLayout_1.IndexType.Single) ||
        (groupIndex === 0 && itemIndex === 0 && StoriesLayout_1.IndexType.Start) ||
        (groupIndex === groups.length - 1 &&
            itemIndex === currentItems.length - 1 &&
            StoriesLayout_1.IndexType.End) ||
        StoriesLayout_1.IndexType.InProccess;
    return (react_1.default.createElement(uikit_1.Modal, { open: open, onClose: handleClose, disableOutsideClick: disableOutsideClick, className: b(), contentClassName: b('modal-content') },
        react_1.default.createElement(components_1.StoriesPreview, { maxSliderItemsCount: maxSliderItemsCount > 0 ? maxSliderItemsCount : 1, groups: groups, groupIndex: groupIndex, onGroupSelect: onGroupSelect, onClose: disableOutsideClick ? undefined : handleClose }),
        react_1.default.createElement(StoriesLayout_1.StoriesLayout, { storyIndex: itemIndex, items: currentItems, indexType: indexType, handleButtonClose: handleButtonClose, handleGotoNext: handleGotoNext, handleGotoPrevious: handleGotoPrevious })));
};
exports.StoriesGroup = StoriesGroup;
