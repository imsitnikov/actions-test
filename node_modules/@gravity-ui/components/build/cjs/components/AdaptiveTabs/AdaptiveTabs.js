"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdaptiveTabs = void 0;
const react_1 = __importDefault(require("react"));
const icons_1 = require("@gravity-ui/icons");
const uikit_1 = require("@gravity-ui/uikit");
const difference_1 = __importDefault(require("lodash/difference"));
const throttle_1 = __importDefault(require("lodash/throttle"));
const resize_observer_polyfill_1 = __importDefault(require("resize-observer-polyfill"));
const cn_1 = require("../utils/cn");
const constants_1 = require("./constants");
const i18n_1 = require("./i18n");
require("./AdaptiveTabs.css");
const SMALL_CONTAINER_WIDTH_NAME = 'small';
const LARGE_CONTAINER_WIDTH_NAME = 'large';
const READY_STATE_COMPLETE = 'complete';
const OUT_OF_SCREEN_POSITION = -99999;
const b = (0, cn_1.block)('adaptive-tabs');
const TAB_CLASS_NAME = b('tab');
const getSortObjectKeysByValuesFunc = (objectToSort) => (a, b) => {
    if (objectToSort[a] > objectToSort[b]) {
        return 1;
    }
    if (objectToSort[a] < objectToSort[b]) {
        return -1;
    }
    return 0;
};
// https://github.com/gravity-ui/components/issues/7
class Tab extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.onClick = (event) => {
            if (this.props.onClick) {
                this.props.onClick(this.props.id, event);
            }
        };
    }
    render() {
        const { active, disabled, hint, title = this.props.id } = this.props;
        const stringTitle = hint !== null && hint !== void 0 ? hint : ((typeof title === 'string' && title) || '');
        return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events
        react_1.default.createElement("div", { className: b('tab', { active, disabled }), title: stringTitle, onClick: disabled ? undefined : this.onClick }, title));
    }
}
class AdaptiveTabs extends react_1.default.Component {
    get activeTab() {
        const { activeTab, items, allowNotSelected } = this.props;
        if (activeTab) {
            return activeTab;
        }
        if (allowNotSelected || items.length === 0) {
            return undefined;
        }
        const [firstTab] = items;
        return firstTab.id;
    }
    constructor(props) {
        super(props);
        this.tabItemPaddingRight = 0;
        this.switcherWidth = 0;
        /* for the convenience of calculations, you will need three objects, whose keys are tab indices and values are tab widths,
         the real width of tabs is considered separately (as if there were no max width limitations)
         and the current tabs width (taking into account max width constraints and width adjustment):
         - real width of the tabs, the values for all tabs will be written */
        this.tabsRealWidth = {};
        /* - the same, but only values for overflowing tabs will be written (it is necessary to have such an object with the values of
         of the overflowed tabs is necessary for calculations of width adjustment of the overflowed tabs) */
        this.overflownTabsRealWidth = {};
        /* - current width of tabs, again, only for crowded tabs */
        this.overflownTabsCurrentWidth = {};
        /* in addition, the array will store the current width of all the tabs, the array is convenient for calculating
         the width of N visible tabs, for example, from the first to the fifth. */
        this.tabsWidth = [];
        /* a flag indicating that the initial acquisition of the dimensions required for further calculations has already taken place */
        this.dimensionsWereInitiallyCollected = true;
        this.selectSwitcherNode = react_1.default.createRef();
        this.tabsRootNode = react_1.default.createRef();
        this.tabsListNode = react_1.default.createRef();
        this.subscribeForResize = () => {
            if (!this.tabsRootNode.current) {
                return;
            }
            this.resizeObserver = new resize_observer_polyfill_1.default(this.throttledHandleResize);
            this.resizeObserver.observe(this.tabsRootNode.current);
        };
        this.initialCollectDimensions = () => {
            /* Because we are expecting fonts to be loaded to measure tab sizes and subscribe to container resize, it is possible
           case that by the time the fonts are loaded the component is already unmounted, so it's necessary to check that the ref at the root
           node exists */
            if (this.tabsRootNode.current) {
                this.dimensionsWereInitiallyCollected = true;
                this.recollectDimensions();
                this.subscribeForResize();
            }
        };
        /*
           The "taking measurements" stage. Once the width of the tabs and some associated dimensions/indentation are calculated
         */
        this.collectDimensions = () => {
            var _a;
            if (!this.tabsRootNode.current || !this.tabsListNode.current) {
                return;
            }
            const tabsListNode = this.tabsListNode.current;
            const tabs = tabsListNode.children;
            this.tabsWidth = [];
            const tabElement = tabsListNode.firstElementChild;
            if (tabElement) {
                const paddingRightValue = window
                    .getComputedStyle(tabElement)
                    .getPropertyValue('padding-right');
                /* save the value of the right padding (the distance between tabs, which can be different depending on
                the value of css variable --gc-tabs-space-between) */
                this.tabItemPaddingRight = paddingRightValue ? parseInt(paddingRightValue, 10) : 0;
            }
            this.overflownTabsRealWidth = {};
            this.tabsRealWidth = {};
            /* bypass all the tabs in the loop and write the current width of each tab to the array this.tabsWidth
            "fill" the objects this.tabsRealWidth and this.overflownTabsRealWidth */
            for (let i = 0; i < tabs.length; i++) {
                const { width } = tabs[i].getBoundingClientRect();
                const tabTextNode = tabs[i].querySelector(`.${TAB_CLASS_NAME}`);
                if (tabTextNode.scrollWidth > tabTextNode.clientWidth) {
                    // when overflow and "..." exists
                    const widthCorrector = i === tabs.length - 1 ? 0 : this.tabItemPaddingRight;
                    this.overflownTabsRealWidth[i] = tabTextNode.scrollWidth + widthCorrector;
                    this.tabsRealWidth[i] = this.overflownTabsRealWidth[i];
                }
                else {
                    this.tabsRealWidth[i] = width;
                }
                this.tabsWidth[i] = width;
            }
            this.switcherWidth = ((_a = this.selectSwitcherNode.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width) || 0;
            this.setState({ dimensionsWereCollected: true });
            this.recalculateTabs();
        };
        this.getCurrentContainerWidthName = () => {
            var _a;
            for (let index = 0; index < this.breakpoints.length; index++) {
                const breakpointWidth = this.breakpoints[index];
                const prevBreakpointWidth = this.breakpoints[index - 1];
                const nextBreakpointWidth = this.breakpoints[index + 1];
                const containerWidth = ((_a = this.tabsRootNode.current) === null || _a === void 0 ? void 0 : _a.clientWidth) || 0;
                const containerWidthLowerOrEqualThanBreakpointWidth = containerWidth <= breakpointWidth;
                const containerWidthBiggerThanBreakpointWidth = containerWidth > breakpointWidth;
                const containerWidthBiggerThanPrevBreakpointWidth = containerWidth < breakpointWidth;
                if (containerWidthLowerOrEqualThanBreakpointWidth && !prevBreakpointWidth) {
                    return SMALL_CONTAINER_WIDTH_NAME;
                }
                else if (containerWidthBiggerThanBreakpointWidth && !nextBreakpointWidth) {
                    return LARGE_CONTAINER_WIDTH_NAME;
                }
                else if (containerWidthBiggerThanPrevBreakpointWidth &&
                    containerWidthLowerOrEqualThanBreakpointWidth) {
                    return `${prevBreakpointWidth}-${breakpointWidth}`;
                }
            }
            return;
        };
        /*
            Recalculating the Layout - Phases 1 and 2
         */
        this.recalculateTabs = () => {
            if (!this.tabsRootNode.current) {
                return;
            }
            // Phases 1 - calculating index of first hidden tab
            const activeTabId = this.activeTab;
            const { tabChosenFromSelectId, firstHiddenTabIndexBeforeRecollection: prevFirstHiddenTabIndex, } = this.state;
            /* activeTabId is ID of the active tab, tabChosenFromSelectId is ID of the tab selected via the switch,
             the tab selected via the switcher becomes active immediately after selection (in this case, these values coincide)
             but if after the user switches (clicks) to the neighboring tab, they will be different again */
            const { items } = this.props;
            const { width: tabsRootNodeWidth } = this.tabsRootNode.current.getBoundingClientRect();
            const activeTabIndex = items.findIndex((item) => item.id === activeTabId);
            const tabChosenFromSelectIndex = items.findIndex((item) => item.id === tabChosenFromSelectId);
            let renderedTabsSumWidth = 0;
            /* firstHiddenTabIndexForSequentialCase - index of the first hidden tab for the case when the tabs are located in
             serial sequence and without taking into account the maximal width of the hidden tab (it is necessary only for
             intermediate calculations)
             firstHiddenTabIndex - index of the first hidden tab in a particular situation (taking into account the width of the tab selected
             through the switch
             by the switcher and the maximum width of the missing tabs (to be stored in the stack)
             firstHiddenTabIndexForSequentialCase and the maximal
             width among the hidden tabs, then in the reverse loop, starting from the tab with the index
             firstHiddenTabIndexForSequentialCase - 1, it is determined how many tabs should be "moved" into
             incomplete, so that even if a tab with the maximum width is chosen by the switcher, its width + width of the visible
             tabs would not exceed the width of the container */
            let firstHiddenTabIndexForSequentialCase = null;
            let firstHiddenTabIndex = items.length;
            /* if we have bypassed all the widths of the tabs without exceeding the container width, the firstHiddenTabIndex
             value equal to the number of tabs will be written, in this way all the tabs will be rendered */
            let maxHiddenTabWidth = 0;
            let emptySpace = 0;
            /* all tab width values will be bypassed in the loop and summed up until the sum + value of
             of the switcher width will not exceed the width of the container */
            for (let i = 0; i < this.tabsWidth.length; i++) {
                renderedTabsSumWidth = renderedTabsSumWidth + this.tabsWidth[i];
                const switcherWidthCorrection = i >= items.length - 1 ? 0 : this.switcherWidth;
                const isOverflown = renderedTabsSumWidth + switcherWidthCorrection > tabsRootNodeWidth;
                if (firstHiddenTabIndexForSequentialCase === null && isOverflown) {
                    firstHiddenTabIndexForSequentialCase = i;
                    /* emptySpace - "empty" space in pixels - the difference between the width of the container and the width
                     of the rendered tabs and the switcher */
                    emptySpace =
                        tabsRootNodeWidth -
                            (renderedTabsSumWidth - this.tabsWidth[i] + this.switcherWidth);
                }
                if (firstHiddenTabIndexForSequentialCase !== null) {
                    const currentTabWidth = this.tabsWidth[i] + (i === items.length - 1 ? this.tabItemPaddingRight : 0);
                    maxHiddenTabWidth = Math.max(maxHiddenTabWidth, currentTabWidth);
                }
            }
            if (maxHiddenTabWidth) {
                let rightSpace = maxHiddenTabWidth - emptySpace;
                for (let j = firstHiddenTabIndexForSequentialCase - 1; j >= 0; j--) {
                    rightSpace = rightSpace - this.tabsWidth[j];
                    if (rightSpace < 0) {
                        firstHiddenTabIndex = j + (tabChosenFromSelectIndex > j ? 0 : 1);
                        break;
                    }
                }
            }
            const activeTabWasNotChosenBySelect = tabChosenFromSelectId && tabChosenFromSelectId !== activeTabId;
            const newFirstHiddenTabIndexLowerThanPrevious = firstHiddenTabIndex < prevFirstHiddenTabIndex;
            /* there are two narrow cases that arise during resizing that require changing the value of tabChosenFromSelectId and
             recalculate the layout:
             1) previously selecting one of the hidden tabs via the switcher, the user switched by click to another tab and reduced
             screen so that the tab chosen earlier by the switcher would no longer fit; in such a case, we reset
             tabChosenFromSelectId value and start recalculation */
            if (activeTabWasNotChosenBySelect && newFirstHiddenTabIndexLowerThanPrevious) {
                this.setState({ tabChosenFromSelectId: null }, this.recalculateTabs);
                return false;
            }
            /* 2) the active tab is not selected via a switcher, the screen size is reduced so that the standard
             sequence, the active tab should not be rendered, but because it is active, it simply can't be
             hide it, so we write its ID into tabChosenFromSelectId and start recalculation */
            if (this.state.tabChosenFromSelectId !== activeTabId &&
                activeTabIndex >= firstHiddenTabIndex &&
                activeTabId !== undefined) {
                this.setState({ tabChosenFromSelectId: activeTabId }, this.recalculateTabs);
                return false;
            }
            this.setState({ firstHiddenTabIndex });
            /*phase 1 is complete, call the method of adjusting the width of the overflowing tabs to fill the entire width of the container*/
            this.setUpOverflownTabs(firstHiddenTabIndex, activeTabIndex, tabsRootNodeWidth);
            return;
        };
        this.recollectDimensions = () => {
            this.setState((state) => ({
                dimensionsWereCollected: false,
                firstHiddenTabIndex: this.props.items.length,
                firstHiddenTabIndexBeforeRecollection: state.firstHiddenTabIndex,
            }), this.collectDimensions);
        };
        /*
            A check which is called in the componentDidUpdate method and checks if the tabs "come" with new props have the same
            order and title as the previous ones. If this is not the case, the collectDimensions method will be called to
            memorize the new props and run the subsequent phases of recalculating the layout
         */
        this.wasItemsListUpdated = (currentItems, prevItems) => {
            if (currentItems.length !== prevItems.length) {
                return true;
            }
            for (let i = 0; i < currentItems.length; i++) {
                const currentItem = currentItems[i];
                const prevItem = prevItems[i];
                const currentItemTitle = currentItem.title || currentItem.id;
                const prevItemTitle = prevItem.title || prevItem.id;
                if (currentItemTitle !== prevItemTitle) {
                    return true;
                }
            }
            return false;
        };
        this.handleResize = () => {
            if (this.state.isSelectOpened) {
                this.setState({ isSelectOpened: false });
            }
            const newContainerWidthName = this.getCurrentContainerWidthName();
            if (this.state.currentContainerWidthName !== newContainerWidthName) {
                this.setState({ currentContainerWidthName: newContainerWidthName }, () => {
                    if (newContainerWidthName !== SMALL_CONTAINER_WIDTH_NAME) {
                        this.recollectDimensions();
                    }
                });
            }
            else if (newContainerWidthName !== SMALL_CONTAINER_WIDTH_NAME) {
                this.recollectDimensions();
            }
        };
        this.onChooseTabFromSelect = (tabChosenFromSelectIds) => {
            const tabChosenFromSelectId = tabChosenFromSelectIds[0];
            this.selectTab(tabChosenFromSelectId);
            this.setState({ tabChosenFromSelectId });
            this.recollectDimensions();
        };
        this.onTabClick = (tabId, event) => {
            if (tabId === this.activeTab) {
                return;
            }
            this.selectTab(tabId, event);
        };
        /*
            Calculates what value of the inline-start property should be set to the absolutely positioned switcher at
            the current set of rendered tabs
         */
        this.calcSelectSwitcherInlineStartPosition = () => {
            const { tabChosenFromSelectId, firstHiddenTabIndex } = this.state;
            const { items } = this.props;
            let tabChosenFromSelectIndex = null;
            if (tabChosenFromSelectId) {
                tabChosenFromSelectIndex = this.props.items.findIndex((item) => item.id === tabChosenFromSelectId);
            }
            let widthCorrection = tabChosenFromSelectId && tabChosenFromSelectIndex > firstHiddenTabIndex
                ? this.tabsWidth[tabChosenFromSelectIndex]
                : 0;
            /* if the last tab is selected, the right margin must be taken into account, because in the position where
               all tabs fit into the container width and there is no switcher, the right margin is not needed for the last tab.
               all tabs do not fit into the container width and there is a switcher to the right of this tab,
               then a margin is needed to prevent the switcher from being flattened */
            if (tabChosenFromSelectIndex === items.length - 1) {
                widthCorrection = widthCorrection + this.tabItemPaddingRight;
            }
            return this.tabsWidth && firstHiddenTabIndex < items.length
                ? this.tabsWidth
                    .slice(0, firstHiddenTabIndex)
                    .reduce((sum, val) => sum + val, widthCorrection)
                : OUT_OF_SCREEN_POSITION;
        };
        this.renderSwitcherForMoreSelect = (switcherProps) => {
            const { firstHiddenTabIndex, tabChosenFromSelectId } = this.state;
            const { items } = this.props;
            const tabChosenFromSelectIndex = items.findIndex((item) => item.id === tabChosenFromSelectId);
            const itemsNum = items.length -
                firstHiddenTabIndex -
                (tabChosenFromSelectIndex > firstHiddenTabIndex ? 1 : 0);
            const hint = (0, i18n_1.i18n)('label_more', { count: itemsNum });
            return this.renderSwitcher(Object.assign(Object.assign({}, switcherProps), { text: hint }));
        };
        this.renderSwitcherForTabsAsSelect = (switcherProps) => {
            var _a;
            const { items } = this.props;
            const activeTab = items.find((item) => item.id === this.activeTab);
            const tab = activeTab !== null && activeTab !== void 0 ? activeTab : items[0];
            const hint = (_a = tab.hint) !== null && _a !== void 0 ? _a : ((typeof tab.title === 'string' && tab.title) || tab.id);
            return this.renderSwitcher(Object.assign(Object.assign({}, switcherProps), { text: hint, active: Boolean(activeTab) }));
        };
        this.renderSwitcher = (switcherProps) => {
            const { wrapTo } = this.props;
            const { onClick, active, ref, text, onKeyDown } = switcherProps;
            const title = (react_1.default.createElement("div", { className: b('switcher-tab-content') },
                react_1.default.createElement("span", { className: b('switcher-tab-text') }, text),
                react_1.default.createElement("span", { className: b('switcher-tab-icon') },
                    react_1.default.createElement(uikit_1.Icon, { className: b('chevron-icon'), data: icons_1.ChevronDown }))));
            const switcherTabProps = { title, hint: text, id: 'switcher-tab' };
            const tabItemNode = react_1.default.createElement(Tab, Object.assign({}, switcherTabProps, { active: Boolean(active) }));
            return (
            // eslint-disable-next-line jsx-a11y/no-static-element-interactions
            react_1.default.createElement("div", { 
                // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
                tabIndex: 0, key: "switcher", onClick: onClick, onKeyDown: onKeyDown, className: b('tab-container', { 'switcher-tab': true }), ref: ref }, wrapTo ? wrapTo(undefined, tabItemNode, undefined) : tabItemNode));
        };
        this.renderTabs = () => {
            const { items } = this.props;
            const { firstHiddenTabIndex, tabChosenFromSelectId } = this.state;
            let tabChosenFromSelectIndex = null;
            if (tabChosenFromSelectId) {
                tabChosenFromSelectIndex = this.props.items.findIndex((item) => item.id === tabChosenFromSelectId);
            }
            const needToAddTabChosenFromSelect = tabChosenFromSelectId && tabChosenFromSelectIndex > firstHiddenTabIndex;
            return items
                .slice(0, firstHiddenTabIndex)
                .concat(needToAddTabChosenFromSelect ? items[tabChosenFromSelectIndex] : [])
                .map((item, index) => this.renderTabItem(item, index < firstHiddenTabIndex ? index : tabChosenFromSelectIndex));
        };
        this.renderTabItem = (item, tabIndex) => {
            const { items, wrapTo } = this.props;
            const activeTabID = this.activeTab;
            const { dimensionsWereCollected, currentContainerWidthName } = this.state;
            const needSetMaxWidth = dimensionsWereCollected && tabIndex in this.overflownTabsCurrentWidth;
            const isLastTab = item.id === items[items.length - 1].id && tabIndex === items.length - 1;
            const noOverflow = needSetMaxWidth &&
                this.overflownTabsRealWidth[tabIndex] === this.overflownTabsCurrentWidth[tabIndex];
            const maxWidth = dimensionsWereCollected
                ? this.overflownTabsCurrentWidth[tabIndex]
                : `${this.tabMaxWidthInPercentsForScreenSize[currentContainerWidthName]}%`;
            const tabNode = react_1.default.createElement(Tab, Object.assign({}, item, { active: item.id === activeTabID }));
            return (
            // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
            react_1.default.createElement("div", { key: item.id, style: { maxWidth: items.length > 1 ? maxWidth : '100%' }, className: b('tab-container', { 'last-tab': isLastTab, 'no-overflow': noOverflow }), onClick: (e) => {
                    if (!item.disabled) {
                        this.onTabClick(item.id, e);
                    }
                } }, wrapTo ? wrapTo(item, tabNode, tabIndex) : tabNode));
        };
        this.handleTabsAsSelectUpdate = (ids) => {
            const tabId = ids[0];
            this.selectTab(tabId);
            this.setState({ tabChosenFromSelectId: tabId });
        };
        this.handleOpenSelectChange = (isSelectOpened) => {
            this.setState({ isSelectOpened });
        };
        this.state = {
            dimensionsWereCollected: false,
            firstHiddenTabIndex: this.props.items.length,
            firstHiddenTabIndexBeforeRecollection: null,
            tabChosenFromSelectId: null,
            currentContainerWidthName: null,
            isSelectOpened: false,
        };
        this.breakpoints = Object.keys(props.breakpointsConfig)
            .map(Number)
            .sort((a, b) => a - b);
        /* save the object, where the keys are the "name" of the current container width, the values are the maximum width of the tab for
        the corresponding container width (in percent of the container width) */
        this.tabMaxWidthInPercentsForScreenSize = this.breakpoints.reduce((accum, currentBreakpointWidth, index, breakpointsArray) => {
            const nextBreakpointWidth = breakpointsArray[index + 1];
            let breakpointName = `${currentBreakpointWidth}-${nextBreakpointWidth}`;
            if (!nextBreakpointWidth) {
                breakpointName = LARGE_CONTAINER_WIDTH_NAME;
            }
            accum[breakpointName] = props.breakpointsConfig[currentBreakpointWidth] || 100;
            return accum;
        }, {});
        this.handleResize = this.handleResize.bind(this);
        this.throttledHandleResize = (0, throttle_1.default)(this.handleResize, 350);
    }
    componentDidMount() {
        if (!this.tabsRootNode.current) {
            return;
        }
        this.setState({ currentContainerWidthName: this.getCurrentContainerWidthName() });
        if (this.tabsRootNode.current.clientWidth > this.breakpoints[0]) {
            if (document.fonts) {
                document.fonts.ready.then(this.initialCollectDimensions);
            }
            else if (document.readyState === READY_STATE_COMPLETE) {
                setTimeout(this.initialCollectDimensions, 0);
            }
            else {
                window.addEventListener('load', this.initialCollectDimensions);
            }
        }
        else {
            this.subscribeForResize();
        }
    }
    componentDidUpdate(prevProps) {
        if (!this.dimensionsWereInitiallyCollected) {
            return;
        }
        if (this.wasItemsListUpdated(this.props.items, prevProps.items)) {
            this.setState({
                dimensionsWereCollected: false,
                firstHiddenTabIndex: this.props.items.length,
                firstHiddenTabIndexBeforeRecollection: null,
            }, () => {
                if (this.state.currentContainerWidthName !== SMALL_CONTAINER_WIDTH_NAME) {
                    this.collectDimensions();
                }
            });
        }
    }
    componentWillUnmount() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
        window.removeEventListener('load', this.collectDimensions);
    }
    setUpOverflownTabs(firstHiddenTabIndex, _activeTabIndex, tabsRootNodeWidth) {
        const { tabChosenFromSelectId } = this.state;
        const { items } = this.props;
        const tabChosenFromSelectIndex = items.findIndex((item) => item.id === tabChosenFromSelectId);
        const allTabsWillBeVisible = firstHiddenTabIndex === items.length;
        const withTabChosenFromSelect = tabChosenFromSelectIndex >= firstHiddenTabIndex;
        /* firstTabParticipatedInShiftingIndex - index of the first tab which participates in the change of the selected tab when
         it is the index of the first tab which participates in switching of the selected tab (in other words it can appear in the dropdown list at the current width of the container)
         it is either the last visible tab (if the selection is not made by the switcher yet) or the first of hidden tabs.
         (otherwise) */
        const firstTabParticipatedInShiftingIndex = firstHiddenTabIndex - (withTabChosenFromSelect ? 0 : 1);
        const alwaysVisibleTabsWidth = this.tabsWidth
            .slice(0, firstHiddenTabIndex - (allTabsWillBeVisible || withTabChosenFromSelect ? 0 : 1))
            .reduce((sum, val) => sum + val, 0);
        /*index of the widest (real width) tab of those that participate in the change of the selected tab*/
        let widestTabParticipatedInShiftingIndex = null;
        let widestHiddenTabRealWidth = 0;
        for (let i = firstTabParticipatedInShiftingIndex; i < items.length; i++) {
            const currentHiddenTabWidth = this.tabsRealWidth[i];
            widestHiddenTabRealWidth = Math.max(currentHiddenTabWidth, widestHiddenTabRealWidth);
            if (widestHiddenTabRealWidth === currentHiddenTabWidth) {
                widestTabParticipatedInShiftingIndex = i;
            }
        }
        const switcherAndMaxHiddenTabWidth = allTabsWillBeVisible
            ? 0
            : this.tabsWidth[widestTabParticipatedInShiftingIndex] + this.switcherWidth;
        const overflownTabsKeys = Object.keys(this.overflownTabsRealWidth);
        /* it is necessary to have a separate array of indexes of overflown tabs which at the moment
         visible (overflownAndVisibleTabsKeys) and separately an array of indexes of overflown tabs which are not currently
         visible (overflownAndHiddenTabsKeys) */
        const overflownAndVisibleTabsKeys = overflownTabsKeys.filter((tabIndex) => Number(tabIndex) < firstTabParticipatedInShiftingIndex ||
            Number(tabIndex) === widestTabParticipatedInShiftingIndex);
        const isLastTabChosenFromSelectAndOverflown = tabChosenFromSelectIndex === items.length - 1 &&
            overflownAndVisibleTabsKeys.indexOf(String(tabChosenFromSelectIndex)) >= 0;
        /* the main idea of adjusting the width of overflowing tabs, to fill the entire width of the container - calculate,
         what "empty" space will be left if the user chose the tab with the maximum width through the switcher and
         divide this space among the overflowing tabs - i.e. increase their width to occupy the full width
         container */
        let emptySpace = tabsRootNodeWidth - alwaysVisibleTabsWidth - switcherAndMaxHiddenTabWidth;
        if (isLastTabChosenFromSelectAndOverflown) {
            emptySpace = emptySpace - this.tabItemPaddingRight;
        }
        const overflownAndHiddenTabsKeys = (0, difference_1.default)(overflownTabsKeys, overflownAndVisibleTabsKeys);
        const overflownAndVisibleTabsIndexesSortedByWidth = overflownAndVisibleTabsKeys
            .sort(getSortObjectKeysByValuesFunc(this.overflownTabsRealWidth))
            .map(Number);
        /*additionPixelsToFitEmptySpace - the value of how many pixels will be added to the width of the crowded tabs */
        let additionPixelsToFitEmptySpace = emptySpace / overflownAndVisibleTabsKeys.length;
        let numberOfTabsToShareEmptySpace = overflownAndVisibleTabsKeys.length;
        this.overflownTabsCurrentWidth = {};
        overflownAndVisibleTabsIndexesSortedByWidth.forEach((overflownTabIndex) => {
            const realTabWidth = this.overflownTabsRealWidth[overflownTabIndex];
            const tabWidthWithAdditional = this.tabsWidth[overflownTabIndex] + additionPixelsToFitEmptySpace;
            if (realTabWidth < tabWidthWithAdditional) {
                /* It can happen that the value "current width of the overflowing tab + additionPixelsToFitEmptySpace"
                 is greater than the real width of the tab, in which case the current width becomes equal to the real width, and
                 it means that we haven't used all the pixels from the
                 overflowing tabs and then we pass those pixels (diff) for the remaining tabs, i.e. those whose width
                 have not been incremented by the current iteration (if there are any). */
                numberOfTabsToShareEmptySpace--;
                const diff = tabWidthWithAdditional - realTabWidth;
                additionPixelsToFitEmptySpace =
                    additionPixelsToFitEmptySpace + diff / numberOfTabsToShareEmptySpace;
                this.tabsWidth[overflownTabIndex] = realTabWidth;
            }
            else {
                this.tabsWidth[overflownTabIndex] = tabWidthWithAdditional;
            }
            this.overflownTabsCurrentWidth[overflownTabIndex] = this.tabsWidth[overflownTabIndex];
        });
        overflownAndHiddenTabsKeys.map(Number).forEach((overflownTabIndex) => {
            const realTabWidth = this.overflownTabsRealWidth[overflownTabIndex];
            const tabWidthWithAdditional = this.tabsWidth[overflownTabIndex] + additionPixelsToFitEmptySpace;
            if (realTabWidth < tabWidthWithAdditional) {
                this.tabsWidth[overflownTabIndex] = realTabWidth;
            }
            else {
                this.tabsWidth[overflownTabIndex] = tabWidthWithAdditional;
            }
            this.overflownTabsCurrentWidth[overflownTabIndex] = this.tabsWidth[overflownTabIndex];
        });
    }
    selectTab(tabId, event) {
        if (this.props.onSelectTab) {
            this.props.onSelectTab(tabId, event);
        }
    }
    renderSelect() {
        const activeTabID = this.activeTab;
        const { firstHiddenTabIndex, tabChosenFromSelectId } = this.state;
        const { items } = this.props;
        const itemsForSelect = items
            .slice(firstHiddenTabIndex, items.length)
            .filter((item) => {
            return item.id !== activeTabID && item.id !== tabChosenFromSelectId;
        })
            .map((item) => ({
            value: item.id,
            content: item.title || item.id,
            key: item.id,
            disabled: item.disabled,
        }));
        return (react_1.default.createElement(uikit_1.Select, { onUpdate: this.onChooseTabFromSelect, options: itemsForSelect, value: [], filterable: false, renderControl: this.renderSwitcherForMoreSelect, onOpenChange: this.handleOpenSelectChange }));
    }
    renderTabsAsSelect() {
        const activeTabID = this.activeTab;
        const { items } = this.props;
        const itemsForSelect = items.map((item) => ({
            value: item.id,
            content: item.title || item.id,
            key: item.id,
            disabled: item.disabled,
        }));
        return (react_1.default.createElement(uikit_1.Select, { className: b('tabs-as-select-control'), onUpdate: this.handleTabsAsSelectUpdate, options: itemsForSelect, value: activeTabID === undefined ? [] : [activeTabID], filterable: false, renderControl: this.renderSwitcherForTabsAsSelect, onOpenChange: this.handleOpenSelectChange }));
    }
    render() {
        const { items, className, size = 'm' } = this.props;
        return (react_1.default.createElement("div", { ref: this.tabsRootNode, className: b({
                size: size,
                visible: this.state.dimensionsWereCollected,
            }, [className]) }, this.state.currentContainerWidthName === SMALL_CONTAINER_WIDTH_NAME &&
            items.length > 1 ? (this.renderTabsAsSelect()) : (react_1.default.createElement(react_1.default.Fragment, null,
            react_1.default.createElement("div", { ref: this.tabsListNode, className: b('tabs-list') }, this.renderTabs()),
            react_1.default.createElement("div", { ref: this.selectSwitcherNode, className: b('select-switcher'), style: { insetInlineStart: this.calcSelectSwitcherInlineStartPosition() } }, this.renderSelect())))));
    }
}
exports.AdaptiveTabs = AdaptiveTabs;
AdaptiveTabs.defaultProps = {
    /* default values of breakpoint configuration - object where the key is the width of the container element, the value is
     maximum width of tab as a percentage of the container width, (so, for default values, if the width of
     container width from 401px to 500px the maximum tab width will be 33%, from 501px to 700px 30%, etc.)
     the width of the container is the minimum of the values defined in the object keys (the default value is 400)
     instead of tabs, select is rendered occupying the entire width of the container. */
    breakpointsConfig: constants_1.DEFAULT_BREAK_POINTS_CONFIG,
};
