"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRelativeRangeDatePickerDialogState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const date_utils_1 = require("@gravity-ui/date-utils");
const datePicker_1 = require("../../../utils/validation/datePicker");
const i18n_1 = require("./i18n");
function useRelativeRangeDatePickerDialogState(state, props) {
    var _a, _b, _c, _d;
    const { withApplyButton, allowNullableValues } = props;
    const [start, setStart] = react_1.default.useState((_b = (_a = state.value) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : null);
    const [end, setEnd] = react_1.default.useState((_d = (_c = state.value) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : null);
    const [innerTimeZone, setTimeZone] = react_1.default.useState(state.timeZone);
    const timeZone = withApplyButton ? innerTimeZone : state.timeZone;
    function setStartValue(newValue) {
        setStart(newValue);
        if (!withApplyButton) {
            state.setValue(getRangeValue(newValue, end, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
        }
    }
    function setEndValue(newValue) {
        setEnd(newValue);
        if (!withApplyButton) {
            state.setValue(getRangeValue(start, newValue, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
        }
    }
    function setTimeZoneValue(newTimeZone) {
        setTimeZone(newTimeZone);
        if (!withApplyButton) {
            state.setValue(getRangeValue(start, end, Object.assign(Object.assign({}, props), { timeZone: newTimeZone })), newTimeZone);
        }
    }
    function setRange(newStart, newEnd) {
        setStart(newStart);
        setEnd(newEnd);
        if (!withApplyButton) {
            state.setValue(getRangeValue(newStart, newEnd, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
        }
    }
    function applyValue() {
        state.setValue(getRangeValue(start, end, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
    }
    const validation = react_1.default.useMemo(() => getRangeValidationResult(start, end, allowNullableValues, props.minValue, props.maxValue, props.isDateUnavailable, timeZone), [
        allowNullableValues,
        end,
        props.isDateUnavailable,
        props.maxValue,
        props.minValue,
        start,
        timeZone,
    ]);
    return {
        start,
        end,
        timeZone,
        setStart: setStartValue,
        setEnd: setEndValue,
        setRange,
        setTimeZone: setTimeZoneValue,
        applyValue,
        isInvalid: validation.isInvalid,
        startValidation: validation.startValidationResult,
        endValidation: validation.endValidationResult,
    };
}
exports.useRelativeRangeDatePickerDialogState = useRelativeRangeDatePickerDialogState;
function getRangeValue(start, end, options = {}) {
    var _a;
    if (!start && !end) {
        return null;
    }
    const { isInvalid } = getRangeValidationResult(start, end, options.allowNullableValues, options.minValue, options.maxValue, options.isDateUnavailable, (_a = options.timeZone) !== null && _a !== void 0 ? _a : 'default');
    if (isInvalid) {
        return null;
    }
    return { start, end };
}
function getRangeValidationResult(start, end, allowNullableValues, minValue, maxValue, isDateUnavailable, timeZone) {
    if (!start && !end) {
        return { isInvalid: false };
    }
    const startDate = start ? (0, date_utils_1.dateTimeParse)(start.value, { timeZone }) : null;
    const endDate = end ? (0, date_utils_1.dateTimeParse)(end.value, { timeZone, roundUp: true }) : null;
    const startValidationResult = (0, datePicker_1.getValidationResult)(startDate, minValue, maxValue, isDateUnavailable, timeZone);
    if (!startDate && !allowNullableValues) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push((0, i18n_1.i18n)('Value is required.'));
    }
    const endValidationResult = (0, datePicker_1.getValidationResult)(endDate, minValue, maxValue, isDateUnavailable, timeZone);
    if (!endDate && !allowNullableValues) {
        endValidationResult.isInvalid = true;
        endValidationResult.errors.push((0, i18n_1.i18n)('Value is required.'));
    }
    if (startDate && endDate && endDate.isBefore(startDate)) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push((0, i18n_1.i18n)(`"From" can't be after "To".`));
    }
    return {
        isInvalid: startValidationResult.isInvalid || endValidationResult.isInvalid,
        startValidationResult,
        endValidationResult,
    };
}
