"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRelativeRangeDatePickerState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const date_utils_1 = require("@gravity-ui/date-utils");
const uikit_1 = require("@gravity-ui/uikit");
const datePicker_1 = require("../../utils/validation/datePicker");
const i18n_1 = require("../i18n");
function useRelativeRangeDatePickerState(props) {
    var _a, _b;
    const [value, setValue] = (0, uikit_1.useControlledState)(props.value, (_a = props.defaultValue) !== null && _a !== void 0 ? _a : null);
    const [timeZone, setTimeZone] = (0, uikit_1.useControlledState)(props.timeZone, (_b = props.defaultTimeZone) !== null && _b !== void 0 ? _b : 'default', props.onUpdateTimeZone);
    const validation = react_1.default.useMemo(() => getRangeValidationResult(value, props.allowNullableValues, props.minValue, props.maxValue, props.isDateUnavailable, timeZone), [
        value,
        props.allowNullableValues,
        props.isDateUnavailable,
        props.maxValue,
        props.minValue,
        timeZone,
    ]);
    return Object.assign({ value,
        timeZone,
        setValue(v, tz) {
            var _a;
            setValue(v);
            setTimeZone(tz);
            if (value !== v || (value && timeZone !== tz)) {
                (_a = props.onUpdate) === null || _a === void 0 ? void 0 : _a.call(props, v, tz);
            }
        } }, validation);
}
exports.useRelativeRangeDatePickerState = useRelativeRangeDatePickerState;
function getRangeValidationResult(value, allowNullableValues, minValue, maxValue, isDateUnavailable, timeZone) {
    if (!value) {
        return { isInvalid: false, errors: [] };
    }
    const startDate = value.start ? (0, date_utils_1.dateTimeParse)(value.start.value, { timeZone }) : null;
    const endDate = value.end ? (0, date_utils_1.dateTimeParse)(value.end.value, { timeZone, roundUp: true }) : null;
    const startValidationResult = (0, datePicker_1.getValidationResult)(startDate, minValue, maxValue, isDateUnavailable, timeZone, (0, i18n_1.i18n)('"From"'));
    if (!startDate && !allowNullableValues) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push((0, i18n_1.i18n)('"From" is required.'));
    }
    const endValidationResult = (0, datePicker_1.getValidationResult)(endDate, minValue, maxValue, isDateUnavailable, timeZone, (0, i18n_1.i18n)('"To"'));
    if (!endDate && !allowNullableValues) {
        endValidationResult.isInvalid = true;
        endValidationResult.errors.push((0, i18n_1.i18n)('"To" is required.'));
    }
    if (startDate && endDate && endDate.isBefore(startDate)) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push((0, i18n_1.i18n)(`"From" can't be after "To".`));
    }
    return {
        isInvalid: startValidationResult.isInvalid || endValidationResult.isInvalid,
        errors: startValidationResult.errors.concat(endValidationResult.errors),
    };
}
