"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRelativeDatePickerProps = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const uikit_1 = require("@gravity-ui/uikit");
const DateField_1 = require("../../DateField");
const RelativeDateField_1 = require("../../RelativeDateField");
const getButtonSizeForInput_1 = require("../../utils/getButtonSizeForInput");
const mergeProps_1 = require("../../utils/mergeProps");
const i18n_1 = require("../i18n");
function useRelativeDatePickerProps(state, _a) {
    var { onFocus, onBlur } = _a, props = tslib_1.__rest(_a, ["onFocus", "onBlur"]);
    const { mode, setMode, datePickerState, relativeDateState } = state;
    const [focusedDate, setFocusedDate] = react_1.default.useState(mode === 'relative'
        ? relativeDateState.lastCorrectDate
        : datePickerState.dateFieldState.displayValue);
    const [prevCorrectDate, setPrevCorrectDate] = react_1.default.useState(relativeDateState.lastCorrectDate);
    if (prevCorrectDate !== relativeDateState.lastCorrectDate) {
        setPrevCorrectDate(relativeDateState.lastCorrectDate);
        setFocusedDate(relativeDateState.lastCorrectDate);
    }
    const [prevDateValue, setPrevDateValue] = react_1.default.useState(datePickerState.dateFieldState.displayValue);
    if (!datePickerState.dateFieldState.displayValue.isSame(prevDateValue, 'day')) {
        setPrevDateValue(datePickerState.dateFieldState.displayValue);
        setFocusedDate(datePickerState.dateFieldState.displayValue);
    }
    const { focusWithinProps } = (0, uikit_1.useFocusWithin)({
        onFocusWithin: onFocus,
        onBlurWithin: onBlur,
        onFocusWithinChange(isFocusWithin) {
            if (!isFocusWithin) {
                state.setActive(false);
            }
        },
    });
    const [isOpen, setOpen] = react_1.default.useState(false);
    if (!state.isActive && isOpen) {
        setOpen(false);
    }
    const [prevOpen, setPrevOpen] = react_1.default.useState(isOpen);
    if (isOpen !== prevOpen) {
        setPrevOpen(isOpen);
        if (!isOpen) {
            // FIXME: use popup afterOpenChange instead.
            setTimeout(() => {
                setFocusedDate(mode === 'relative'
                    ? relativeDateState.lastCorrectDate
                    : datePickerState.dateFieldState.displayValue);
            }, 200);
        }
    }
    const commonInputProps = {
        onFocus: () => {
            if (!state.isActive) {
                state.setActive(true);
                setOpen(true);
            }
        },
        errorMessage: props.errorMessage,
        errorPlacement: props.errorPlacement,
    };
    const { inputProps } = (0, DateField_1.useDateFieldProps)(datePickerState.dateFieldState, Object.assign(Object.assign({}, props), { value: undefined, defaultValue: undefined, onUpdate: undefined }));
    const { inputProps: relativeDateProps } = (0, RelativeDateField_1.useRelativeDateFieldProps)(relativeDateState, Object.assign(Object.assign({}, props), { value: undefined, defaultValue: undefined, onUpdate: undefined }));
    let validationState = props.validationState;
    if (!validationState) {
        validationState =
            mode === 'relative'
                ? relativeDateState.validationState
                : datePickerState.dateFieldState.validationState;
    }
    const inputRef = react_1.default.useRef(null);
    const handleRef = (0, uikit_1.useForkRef)(inputRef, mode === 'relative' ? relativeDateProps.controlRef : inputProps.controlRef);
    const calendarRef = react_1.default.useRef(null);
    function focusCalendar() {
        setTimeout(() => {
            var _a;
            (_a = calendarRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        });
    }
    function focusInput() {
        setTimeout(() => {
            var _a;
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        });
    }
    return {
        groupProps: Object.assign(Object.assign({ tabIndex: -1, role: 'group' }, focusWithinProps), { onKeyDown: (e) => {
                if (e.altKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
                    e.preventDefault();
                    e.stopPropagation();
                    setOpen(true);
                    focusCalendar();
                }
            } }),
        fieldProps: (0, mergeProps_1.mergeProps)(commonInputProps, mode === 'relative' ? relativeDateProps : inputProps, mode === 'absolute' &&
            datePickerState.dateFieldState.isEmpty &&
            !state.isActive &&
            props.placeholder
            ? { value: '' }
            : undefined, { controlRef: handleRef, validationState }),
        modeSwitcherProps: {
            size: (0, getButtonSizeForInput_1.getButtonSizeForInput)(props.size),
            disabled: state.readOnly || state.disabled,
            view: 'flat-secondary',
            style: { zIndex: 2, marginInlineEnd: 2 },
            selected: mode === 'relative',
            extraProps: {
                'aria-label': (0, i18n_1.i18n)('Formula input mode'),
            },
            onClick: () => {
                setMode(mode === 'relative' ? 'absolute' : 'relative');
                if (mode === 'relative') {
                    const valueDate = datePickerState.value;
                    if (valueDate) {
                        setFocusedDate(valueDate);
                    }
                }
                else if (relativeDateState.parsedDate) {
                    setFocusedDate(relativeDateState.parsedDate);
                }
                focusInput();
            },
        },
        calendarButtonProps: {
            size: (0, getButtonSizeForInput_1.getButtonSizeForInput)(props.size),
            disabled: state.disabled,
            extraProps: {
                'aria-label': (0, i18n_1.i18n)('Calendar'),
                'aria-haspopup': 'dialog',
                'aria-expanded': isOpen,
            },
            view: 'flat-secondary',
            onClick: () => {
                state.setActive(true);
                setOpen(!isOpen);
                if (!isOpen) {
                    focusCalendar();
                }
            },
        },
        popupProps: {
            open: isOpen,
            onEscapeKeyDown: () => {
                setOpen(false);
                focusInput();
            },
        },
        calendarProps: {
            ref: calendarRef,
            size: props.size === 's' ? 'm' : props.size,
            readOnly: props.readOnly,
            value: state.selectedDate,
            onUpdate: (v) => {
                datePickerState.setDateValue(v);
                if (!state.datePickerState.hasTime) {
                    setOpen(false);
                    focusInput();
                }
            },
            focusedValue: focusedDate,
            onFocusUpdate: setFocusedDate,
            minValue: props.minValue,
            maxValue: props.maxValue,
        },
        timeInputProps: {
            value: datePickerState.timeValue,
            onUpdate: datePickerState.setTimeValue,
            format: datePickerState.timeFormat,
            readOnly: state.readOnly,
            disabled: state.disabled,
            timeZone: props.timeZone,
            hasClear: props.hasClear,
            size: props.size,
        },
    };
}
exports.useRelativeDatePickerProps = useRelativeDatePickerProps;
