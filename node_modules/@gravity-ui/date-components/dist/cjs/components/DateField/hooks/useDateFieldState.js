"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDateFieldState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const date_utils_1 = require("@gravity-ui/date-utils");
const uikit_1 = require("@gravity-ui/uikit");
const dates_1 = require("../../utils/dates");
const useDefaultTimeZone_1 = require("../../utils/useDefaultTimeZone");
const utils_1 = require("../utils");
const useBaseDateFieldState_1 = require("./useBaseDateFieldState");
function useDateFieldState(props) {
    var _a, _b;
    const [value, setDate] = (0, uikit_1.useControlledState)(props.value, (_a = props.defaultValue) !== null && _a !== void 0 ? _a : null, props.onUpdate);
    const inputTimeZone = (0, useDefaultTimeZone_1.useDefaultTimeZone)(props.value || props.defaultValue || props.placeholderValue);
    const timeZone = props.timeZone || inputTimeZone;
    const handleUpdateDate = (v) => {
        setDate(v ? v.timeZone(inputTimeZone) : v);
    };
    const [placeholderDate, setPlaceholderDate] = react_1.default.useState(() => {
        return (0, dates_1.createPlaceholderValue)({
            placeholderValue: props.placeholderValue,
            timeZone,
        });
    });
    const format = props.format || 'L';
    const sections = (0, utils_1.useFormatSections)(format);
    const allSegments = react_1.default.useMemo(() => sections
        .filter((seg) => utils_1.EDITABLE_SEGMENTS[seg.type])
        .reduce((p, seg) => (Object.assign(Object.assign({}, p), { [seg.type]: true })), {}), [sections]);
    const validSegmentsState = react_1.default.useState(() => value ? Object.assign({}, allSegments) : {});
    let validSegments = validSegmentsState[0];
    const setValidSegments = validSegmentsState[1];
    if (value && !(0, utils_1.isAllSegmentsValid)(allSegments, validSegments)) {
        setValidSegments(Object.assign({}, allSegments));
    }
    if (!value &&
        (0, utils_1.isAllSegmentsValid)(allSegments, validSegments) &&
        Object.keys(validSegments).length === Object.keys(allSegments).length) {
        validSegments = {};
        setValidSegments(validSegments);
        setPlaceholderDate((0, dates_1.createPlaceholderValue)({
            placeholderValue: props.placeholderValue,
            timeZone,
        }));
    }
    const displayValue = value && (0, date_utils_1.isValid)(value) && (0, utils_1.isAllSegmentsValid)(allSegments, validSegments)
        ? value.timeZone(timeZone)
        : placeholderDate.timeZone(timeZone);
    const sectionsState = useSectionsState(sections, displayValue, validSegments);
    const [selectedSections, setSelectedSections] = react_1.default.useState(-1);
    const selectedSectionIndexes = react_1.default.useMemo(() => {
        if (selectedSections === -1) {
            return null;
        }
        if (selectedSections === 'all') {
            return {
                startIndex: 0,
                endIndex: sectionsState.editableSections.length - 1,
            };
        }
        if (typeof selectedSections === 'number') {
            return { startIndex: selectedSections, endIndex: selectedSections };
        }
        if (typeof selectedSections === 'string') {
            const selectedSectionIndex = sectionsState.editableSections.findIndex((section) => section.type === selectedSections);
            return { startIndex: selectedSectionIndex, endIndex: selectedSectionIndex };
        }
        return selectedSections;
    }, [selectedSections, sectionsState.editableSections]);
    function setValue(newValue) {
        if (props.disabled || props.readOnly) {
            return;
        }
        if ((0, utils_1.isAllSegmentsValid)(allSegments, validSegments)) {
            if (!value || !newValue.isSame(value)) {
                handleUpdateDate(newValue);
            }
        }
        else {
            if (value) {
                handleUpdateDate(null);
            }
            setPlaceholderDate(newValue);
        }
    }
    function markValid(part) {
        validSegments[part] = true;
        if (validSegments.day && validSegments.month && validSegments.year && allSegments.weekday) {
            validSegments.weekday = true;
        }
        if (validSegments.hour && allSegments.dayPeriod) {
            validSegments.dayPeriod = true;
        }
        setValidSegments(Object.assign({}, validSegments));
    }
    function setSection(sectionIndex, amount) {
        const section = sectionsState.editableSections[sectionIndex];
        if (section) {
            markValid(section.type);
            setValue((0, utils_1.setSegment)(section, displayValue, amount));
        }
    }
    function adjustSection(sectionIndex, amount) {
        const section = sectionsState.editableSections[sectionIndex];
        if (section) {
            if (validSegments[section.type]) {
                setValue((0, utils_1.addSegment)(section, displayValue, amount));
            }
            else {
                markValid(section.type);
                if (Object.keys(validSegments).length >= Object.keys(allSegments).length) {
                    setValue(displayValue);
                }
            }
        }
    }
    function flushValidSection(sectionIndex) {
        const section = sectionsState.editableSections[sectionIndex];
        if (section) {
            delete validSegments[section.type];
        }
        setValidSegments(Object.assign({}, validSegments));
    }
    function flushAllValidSections() {
        validSegments = {};
        setValidSegments({});
    }
    function getSectionValue(_sectionIndex) {
        return displayValue;
    }
    function setSectionValue(_sectionIndex, currentValue) {
        setValue(currentValue);
    }
    function createPlaceholder() {
        return (0, dates_1.createPlaceholderValue)({
            placeholderValue: props.placeholderValue,
            timeZone,
        }).timeZone(timeZone);
    }
    function setValueFromString(str) {
        const date = (0, utils_1.parseDateFromString)(str, props.format || 'L', timeZone);
        if ((0, date_utils_1.isValid)(date)) {
            handleUpdateDate(date);
            return true;
        }
        return false;
    }
    const validationState = props.validationState ||
        ((0, dates_1.isInvalid)(value, props.minValue, props.maxValue) ? 'invalid' : undefined) ||
        (value && ((_b = props.isDateUnavailable) === null || _b === void 0 ? void 0 : _b.call(props, value)) ? 'invalid' : undefined);
    return (0, useBaseDateFieldState_1.useBaseDateFieldState)({
        value,
        displayValue,
        placeholderValue: props.placeholderValue,
        timeZone,
        validationState,
        editableSections: sectionsState.editableSections,
        readOnly: props.readOnly,
        disabled: props.disabled,
        selectedSectionIndexes,
        selectedSections,
        isEmpty: Object.keys(validSegments).length === 0,
        flushAllValidSections,
        flushValidSection,
        setSelectedSections,
        setValue,
        setDate: handleUpdateDate,
        adjustSection,
        setSection,
        getSectionValue,
        setSectionValue,
        createPlaceholder,
        setValueFromString,
    });
}
exports.useDateFieldState = useDateFieldState;
function useSectionsState(sections, value, validSegments) {
    const [state, setState] = react_1.default.useState(() => {
        return {
            value,
            sections,
            validSegments,
            editableSections: (0, utils_1.getEditableSections)(sections, value, validSegments),
        };
    });
    if (sections !== state.sections ||
        validSegments !== state.validSegments ||
        !value.isSame(state.value) ||
        value.timeZone() !== state.value.timeZone()) {
        setState({
            value,
            sections,
            validSegments,
            editableSections: (0, utils_1.getEditableSections)(sections, value, validSegments),
        });
    }
    return state;
}
