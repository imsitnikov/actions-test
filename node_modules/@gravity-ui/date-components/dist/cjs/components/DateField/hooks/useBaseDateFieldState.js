"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBaseDateFieldState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const dates_1 = require("../../utils/dates");
const utils_1 = require("../utils");
const PAGE_STEP = {
    year: 5,
    month: 2,
    weekday: 3,
    day: 7,
    hour: 2,
    minute: 15,
    second: 15,
};
function useBaseDateFieldState(props) {
    const { value, validationState, displayValue, editableSections, selectedSectionIndexes, selectedSections, isEmpty, flushAllValidSections, flushValidSection, setSelectedSections, setValue, setDate, adjustSection, setSection, getSectionValue, setSectionValue, createPlaceholder, setValueFromString, } = props;
    const enteredKeys = react_1.default.useRef('');
    const { hasDate, hasTime } = react_1.default.useMemo(() => {
        let hasDateInner = false;
        let hasTimeInner = false;
        for (const s of editableSections) {
            hasTimeInner || (hasTimeInner = ['hour', 'minute', 'second'].includes(s.type));
            hasDateInner || (hasDateInner = ['day', 'month', 'year'].includes(s.type));
        }
        return {
            hasTime: hasTimeInner,
            hasDate: hasDateInner,
        };
    }, [editableSections]);
    return {
        value,
        isEmpty,
        displayValue,
        setValue,
        text: (0, utils_1.formatSections)(editableSections),
        readOnly: props.readOnly,
        disabled: props.disabled,
        sections: editableSections,
        hasDate,
        hasTime,
        selectedSectionIndexes,
        validationState,
        setSelectedSections(position) {
            enteredKeys.current = '';
            setSelectedSections(position);
        },
        focusSectionInPosition(position) {
            const nextSectionIndex = this.sections.findIndex((s) => s.end >= position);
            const index = nextSectionIndex === -1 ? 0 : nextSectionIndex;
            const nextSection = this.sections[index];
            if (nextSection) {
                this.setSelectedSections(utils_1.EDITABLE_SEGMENTS[nextSection.type] ? index : nextSection.nextEditableSection);
            }
        },
        focusNextSection() {
            var _a, _b;
            const currentIndex = selectedSections === 'all' ? 0 : selectedSections;
            const newIndex = (_b = (_a = this.sections[currentIndex]) === null || _a === void 0 ? void 0 : _a.nextEditableSection) !== null && _b !== void 0 ? _b : -1;
            if (newIndex !== -1) {
                this.setSelectedSections(newIndex);
            }
        },
        focusPreviousSection() {
            var _a, _b;
            const currentIndex = selectedSections === 'all' ? 0 : selectedSections;
            const newIndex = (_b = (_a = this.sections[currentIndex]) === null || _a === void 0 ? void 0 : _a.previousEditableSection) !== null && _b !== void 0 ? _b : -1;
            if (newIndex !== -1) {
                this.setSelectedSections(newIndex);
            }
        },
        focusFirstSection() {
            var _a, _b;
            const newIndex = (_b = (_a = this.sections[0]) === null || _a === void 0 ? void 0 : _a.previousEditableSection) !== null && _b !== void 0 ? _b : -1;
            if (newIndex !== -1) {
                setSelectedSections(newIndex);
            }
        },
        focusLastSection() {
            var _a, _b;
            const newIndex = (_b = (_a = this.sections[this.sections.length - 1]) === null || _a === void 0 ? void 0 : _a.nextEditableSection) !== null && _b !== void 0 ? _b : -1;
            if (newIndex !== -1) {
                this.setSelectedSections(newIndex);
            }
        },
        increment() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex !== -1) {
                adjustSection(sectionIndex, 1);
            }
        },
        decrement() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex !== -1) {
                adjustSection(sectionIndex, -1);
            }
        },
        incrementPage() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex !== -1) {
                adjustSection(sectionIndex, PAGE_STEP[this.sections[sectionIndex].type] || 1);
            }
        },
        decrementPage() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex !== -1) {
                adjustSection(sectionIndex, -(PAGE_STEP[this.sections[sectionIndex].type] || 1));
            }
        },
        incrementToMax() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex !== -1) {
                const section = this.sections[sectionIndex];
                if (typeof section.maxValue === 'number') {
                    setSection(sectionIndex, section.maxValue);
                }
            }
        },
        decrementToMin() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex !== -1) {
                const section = this.sections[sectionIndex];
                if (typeof section.minValue === 'number') {
                    setSection(sectionIndex, section.minValue);
                }
            }
        },
        clearSection() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            if (selectedSections === 'all') {
                this.clearAll();
                return;
            }
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex === -1) {
                return;
            }
            flushValidSection(sectionIndex);
            const section = this.sections[sectionIndex];
            const placeholder = (0, dates_1.createPlaceholderValue)({
                placeholderValue: props.placeholderValue,
                timeZone: props.timeZone,
            }).timeZone(props.timeZone);
            const displayPortion = getSectionValue(sectionIndex);
            let currentValue = displayPortion;
            // Reset day period to default without changing the hour.
            if (section.type === 'dayPeriod') {
                const isPM = displayPortion.hour() >= 12;
                const shouldBePM = placeholder.hour() >= 12;
                if (isPM && !shouldBePM) {
                    currentValue = displayPortion.set('hour', displayPortion.hour() - 12);
                }
                else if (!isPM && shouldBePM) {
                    currentValue = displayPortion.set('hour', displayPortion.hour() + 12);
                }
            }
            else {
                const type = (0, utils_1.getDurationUnitFromSectionType)(section.type);
                currentValue = displayPortion.set(type, placeholder[type]());
            }
            setSectionValue(sectionIndex, currentValue);
        },
        clearAll() {
            if (this.readOnly || this.disabled) {
                return;
            }
            enteredKeys.current = '';
            flushAllValidSections();
            if (value !== null) {
                setDate(null);
            }
            const date = createPlaceholder();
            setValue(date);
        },
        onInput(key) {
            if (this.readOnly || this.disabled) {
                return;
            }
            const sectionIndex = (0, utils_1.getCurrentEditableSectionIndex)(this.sections, selectedSections);
            if (sectionIndex === -1) {
                return;
            }
            const section = this.sections[sectionIndex];
            let newValue = enteredKeys.current + key;
            const onInputNumber = (numberValue) => {
                var _a, _b, _c;
                let sectionValue = section.type === 'month' ? numberValue - 1 : numberValue;
                const allowsZero = section.minValue === 0;
                if (section.type === 'hour' &&
                    (section.minValue === 12 || section.maxValue === 11)) {
                    if (numberValue > 12) {
                        sectionValue = Number(key);
                    }
                    if (section.minValue === 12 && sectionValue > 1) {
                        sectionValue += 12;
                    }
                }
                else if (sectionValue > ((_a = section.maxValue) !== null && _a !== void 0 ? _a : 0)) {
                    sectionValue = Number(key) - (section.type === 'month' ? 1 : 0);
                    newValue = key;
                    if (sectionValue > ((_b = section.maxValue) !== null && _b !== void 0 ? _b : 0)) {
                        enteredKeys.current = '';
                        return;
                    }
                }
                const shouldSetValue = sectionValue > 0 || (sectionValue === 0 && allowsZero);
                if (shouldSetValue) {
                    setSection(sectionIndex, sectionValue);
                }
                if (Number(numberValue + '0') > ((_c = section.maxValue) !== null && _c !== void 0 ? _c : 0) ||
                    newValue.length >= String(section.maxValue).length) {
                    enteredKeys.current = '';
                    if (shouldSetValue) {
                        this.focusNextSection();
                    }
                }
                else {
                    enteredKeys.current = newValue;
                }
            };
            const onInputString = (stringValue) => {
                var _a;
                const options = (_a = section.options) !== null && _a !== void 0 ? _a : [];
                let sectionValue = stringValue.toLocaleUpperCase();
                let foundOptions = options.filter((v) => v.startsWith(sectionValue));
                if (foundOptions.length === 0) {
                    if (stringValue !== key) {
                        sectionValue = key.toLocaleUpperCase();
                        foundOptions = options.filter((v) => v.startsWith(sectionValue));
                    }
                    if (foundOptions.length === 0) {
                        enteredKeys.current = '';
                        return;
                    }
                }
                const foundValue = foundOptions[0];
                const index = options.indexOf(foundValue);
                if (section.type === 'dayPeriod') {
                    setSection(sectionIndex, index === 1 ? 12 : 0);
                }
                else {
                    setSection(sectionIndex, index);
                }
                if (foundOptions.length > 1) {
                    enteredKeys.current = newValue;
                }
                else {
                    enteredKeys.current = '';
                    this.focusNextSection();
                }
            };
            switch (section.type) {
                case 'day':
                case 'hour':
                case 'minute':
                case 'second':
                case 'year': {
                    if (!Number.isInteger(Number(newValue))) {
                        return;
                    }
                    const numberValue = Number(newValue);
                    onInputNumber(numberValue);
                    break;
                }
                case 'dayPeriod': {
                    onInputString(newValue);
                    break;
                }
                case 'weekday':
                case 'month': {
                    if (Number.isInteger(Number(newValue))) {
                        const numberValue = Number(newValue);
                        onInputNumber(numberValue);
                    }
                    else {
                        onInputString(newValue);
                    }
                    break;
                }
            }
        },
        setValueFromString(str) {
            enteredKeys.current = '';
            return setValueFromString(str);
        },
    };
}
exports.useBaseDateFieldState = useBaseDateFieldState;
