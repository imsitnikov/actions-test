"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDatePickerState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const uikit_1 = require("@gravity-ui/uikit");
const DateField_1 = require("../../DateField");
const dates_1 = require("../../utils/dates");
const useDefaultTimeZone_1 = require("../../utils/useDefaultTimeZone");
function useDatePickerState(props) {
    var _a;
    const { disabled, readOnly } = props;
    const [isOpen, setOpen] = react_1.default.useState(false);
    const [value, setValue] = (0, uikit_1.useControlledState)(props.value, (_a = props.defaultValue) !== null && _a !== void 0 ? _a : null, props.onUpdate);
    const [selectedDateInner, setSelectedDate] = react_1.default.useState(null);
    const [selectedTimeInner, setSelectedTime] = react_1.default.useState(null);
    const inputTimeZone = (0, useDefaultTimeZone_1.useDefaultTimeZone)(props.value || props.defaultValue || props.placeholderValue);
    const timeZone = props.timeZone || inputTimeZone;
    let selectedDate = selectedDateInner;
    let selectedTime = selectedTimeInner;
    const format = props.format || 'L';
    const commitValue = (date, time) => {
        if (disabled || readOnly) {
            return;
        }
        setValue((0, dates_1.mergeDateTime)(date, time).timeZone(inputTimeZone));
        setSelectedDate(null);
        setSelectedTime(null);
    };
    const dateFieldState = (0, DateField_1.useDateFieldState)({
        value,
        onUpdate(date) {
            if (date) {
                commitValue(date, date);
            }
            else {
                setValue(null);
            }
        },
        disabled,
        readOnly,
        validationState: props.validationState,
        minValue: props.minValue,
        maxValue: props.maxValue,
        isDateUnavailable: props.isDateUnavailable,
        format,
        placeholderValue: props.placeholderValue,
        timeZone,
    });
    const timeFormat = react_1.default.useMemo(() => {
        const hasSeconds = dateFieldState.sections.some((s) => s.type === 'second');
        return hasSeconds ? 'LTS' : 'LT';
    }, [dateFieldState.sections]);
    if (value) {
        selectedDate = value.timeZone(timeZone);
        if (dateFieldState.hasTime) {
            selectedTime = value.timeZone(timeZone);
        }
    }
    // Intercept setValue to make sure the Time section is not changed by date selection in Calendar
    const selectDate = (newValue) => {
        if (disabled || readOnly) {
            return;
        }
        const shouldClose = !dateFieldState.hasTime;
        if (dateFieldState.hasTime) {
            if (selectedTime || shouldClose) {
                commitValue(newValue, selectedTime || newValue);
            }
            else {
                setSelectedDate(newValue);
            }
        }
        else {
            commitValue(newValue, newValue);
        }
        if (shouldClose) {
            setOpen(false);
        }
    };
    const selectTime = (newValue) => {
        if (disabled || readOnly) {
            return;
        }
        const newTime = newValue !== null && newValue !== void 0 ? newValue : (0, dates_1.createPlaceholderValue)({
            placeholderValue: props.placeholderValue,
            timeZone,
        });
        if (selectedDate) {
            commitValue(selectedDate, newTime);
        }
        else {
            setSelectedTime(newTime);
        }
    };
    if (dateFieldState.hasTime && !selectedTime) {
        selectedTime = dateFieldState.displayValue;
    }
    return {
        value,
        setValue(newDate) {
            if (props.readOnly || props.disabled) {
                return;
            }
            if (newDate) {
                setValue(newDate.timeZone(inputTimeZone));
            }
            else {
                setValue(null);
            }
        },
        dateValue: selectedDate,
        timeValue: selectedTime,
        setDateValue: selectDate,
        setTimeValue: selectTime,
        disabled,
        readOnly,
        format,
        hasDate: dateFieldState.hasDate,
        hasTime: dateFieldState.hasTime,
        timeFormat,
        timeZone,
        isOpen,
        setOpen(newIsOpen) {
            if (!newIsOpen && !value && selectedDate && dateFieldState.hasTime) {
                commitValue(selectedDate, selectedTime ||
                    (0, dates_1.createPlaceholderValue)({
                        placeholderValue: props.placeholderValue,
                        timeZone: inputTimeZone,
                    }));
            }
            setOpen(newIsOpen);
        },
        dateFieldState,
    };
}
exports.useDatePickerState = useDatePickerState;
