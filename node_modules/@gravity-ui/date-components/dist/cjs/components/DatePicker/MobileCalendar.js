"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MobileCalendarIcon = exports.MobileCalendar = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const date_utils_1 = require("@gravity-ui/date-utils");
const icons_1 = require("@gravity-ui/icons");
const uikit_1 = require("@gravity-ui/uikit");
const cn_1 = require("../../utils/cn");
const dates_1 = require("../utils/dates");
const getButtonSizeForInput_1 = require("../utils/getButtonSizeForInput");
require("./MobileCalendar.css");
const b = (0, cn_1.block)('mobile-calendar');
function MobileCalendar({ props, state }) {
    var _a, _b;
    let type = 'date';
    if (state.hasTime && state.hasDate) {
        type = 'datetime-local';
    }
    else if (state.hasTime) {
        type = 'time';
    }
    return ((0, jsx_runtime_1.jsx)("input", { className: b('input'), disabled: props.disabled, type: type, value: formatNative(state.dateFieldState.displayValue, type), id: props.id, min: formatNative((_a = props.minValue) === null || _a === void 0 ? void 0 : _a.timeZone(state.timeZone), type), max: formatNative((_b = props.maxValue) === null || _b === void 0 ? void 0 : _b.timeZone(state.timeZone), type), tabIndex: -1, onChange: (e) => {
            var _a, _b;
            if (props.readOnly) {
                return;
            }
            const newValue = e.target.value;
            if (newValue) {
                const localDate = (0, date_utils_1.dateTime)({
                    input: newValue,
                    format: getDateFormat(type),
                    timeZone: 'system',
                }).timeZone(state.timeZone, true);
                let newDate = state.hasDate
                    ? localDate
                    : (0, dates_1.createPlaceholderValue)({
                        placeholderValue: (_a = props.placeholderValue) === null || _a === void 0 ? void 0 : _a.timeZone(state.timeZone),
                        timeZone: state.timeZone,
                    });
                if (state.hasTime) {
                    newDate = (0, dates_1.mergeDateTime)(newDate, localDate);
                }
                else if (state.value) {
                    newDate = (0, dates_1.mergeDateTime)(newDate, state.value.timeZone(state.timeZone));
                }
                else {
                    newDate = (0, dates_1.mergeDateTime)(newDate, (0, dates_1.createPlaceholderValue)({
                        placeholderValue: (_b = props.placeholderValue) === null || _b === void 0 ? void 0 : _b.timeZone(state.timeZone),
                        timeZone: state.timeZone,
                    }));
                }
                state.setValue(newDate);
            }
            else {
                state.setValue(null);
            }
        } }));
}
exports.MobileCalendar = MobileCalendar;
function MobileCalendarIcon({ props }) {
    return ((0, jsx_runtime_1.jsx)("span", { className: b({ size: (0, getButtonSizeForInput_1.getButtonSizeForInput)(props.size) }), children: (0, jsx_runtime_1.jsx)("span", { className: b('button'), children: (0, jsx_runtime_1.jsx)(uikit_1.Icon, { data: icons_1.Calendar }) }) }));
}
exports.MobileCalendarIcon = MobileCalendarIcon;
function getDateFormat(type) {
    switch (type) {
        case 'time': {
            return 'HH:mm';
        }
        case 'datetime-local': {
            return 'YYYY-MM-DDTHH:mm';
        }
        default: {
            return 'YYYY-MM-DD';
        }
    }
}
function formatNative(date, type) {
    if (!date) {
        return '';
    }
    const format = getDateFormat(type);
    return date.format(format);
}
