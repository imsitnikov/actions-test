"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarView = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importDefault(require("react"));
const icons_1 = require("@gravity-ui/icons");
const uikit_1 = require("@gravity-ui/uikit");
const cn_1 = require("../../utils/cn");
const useCalendarCellProps_1 = require("./hooks/useCalendarCellProps");
const useCalendarGridProps_1 = require("./hooks/useCalendarGridProps");
const useCalendarProps_1 = require("./hooks/useCalendarProps");
const utils_1 = require("./utils");
require("./Calendar.css");
const b = (0, cn_1.block)('calendar');
exports.CalendarView = react_1.default.forwardRef(function Calendar(props, ref) {
    const { state } = props;
    const { calendarProps, modeButtonProps, nextButtonProps, previousButtonProps } = (0, useCalendarProps_1.useCalendarProps)(props, state);
    react_1.default.useImperativeHandle(ref, () => ({
        focus() {
            state.setFocused(true);
        },
    }));
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({}, calendarProps, { className: b({ size: props.size }), children: [(0, jsx_runtime_1.jsxs)("div", { className: b('header'), children: [(0, jsx_runtime_1.jsx)(uikit_1.Button, Object.assign({}, modeButtonProps, { view: "flat", size: props.size, children: state.availableModes.indexOf(state.mode) + 1 ===
                            state.availableModes.length ? ((0, jsx_runtime_1.jsx)("span", { className: b('mode-label', b(`years-label`)), children: modeButtonProps.children }, "label")) : ([
                            (0, jsx_runtime_1.jsx)("span", { className: b('mode-label'), children: modeButtonProps.children }, "label"),
                            (0, jsx_runtime_1.jsx)(uikit_1.Button.Icon, { children: (0, jsx_runtime_1.jsx)(uikit_1.ArrowToggle, { direction: "bottom" }) }, "icon"),
                        ]) })), (0, jsx_runtime_1.jsxs)("div", { className: b('controls'), children: [(0, jsx_runtime_1.jsx)(uikit_1.Button, Object.assign({}, previousButtonProps, { view: "flat", size: props.size, children: (0, jsx_runtime_1.jsx)(uikit_1.Button.Icon, { children: (0, jsx_runtime_1.jsx)(icons_1.ChevronLeft, { className: b('control-icon') }) }) })), (0, jsx_runtime_1.jsx)(uikit_1.Button, Object.assign({}, nextButtonProps, { view: "flat", size: props.size, children: (0, jsx_runtime_1.jsx)(uikit_1.Button.Icon, { children: (0, jsx_runtime_1.jsx)(icons_1.ChevronRight, { className: b('control-icon') }) }) }))] })] }), (0, jsx_runtime_1.jsx)(CalendarGrid, { state: state })] })));
});
function CalendarGrid({ state }) {
    const [prevState, setPrevState] = react_1.default.useState(() => (Object.assign(Object.assign({}, state), { isFocused: false })));
    const modeChanged = state.mode !== prevState.mode;
    const startDateChanged = !state.startDate.isSame(prevState.startDate, 'days');
    let animation;
    if (modeChanged) {
        if (utils_1.calendarLayouts.indexOf(prevState.mode) > utils_1.calendarLayouts.indexOf(state.mode)) {
            animation = 'zoom-out';
        }
        else {
            animation = 'zoom-in';
        }
    }
    else if (startDateChanged) {
        if (state.startDate.isBefore(prevState.startDate)) {
            animation = 'forward';
        }
        else {
            animation = 'backward';
        }
    }
    const { gridProps } = (0, useCalendarGridProps_1.useCalendarGridProps)(state);
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: b('grid') }, gridProps, { children: [animation && ((0, jsx_runtime_1.jsx)(Content, { className: b('previous-state'), state: prevState, animation: animation })), (0, jsx_runtime_1.jsx)(Content, { className: b('current-state'), state: state, animation: animation, onAnimationEnd: () => {
                    setPrevState(Object.assign(Object.assign({}, state), { isFocused: false }));
                } }, "current")] })));
}
function Content({ className, state, animation, onAnimationEnd }) {
    return ((0, jsx_runtime_1.jsxs)("div", { className: b('content', { animation }, className), onAnimationEnd: onAnimationEnd, role: "presentation", children: [state.mode === 'days' && (0, jsx_runtime_1.jsx)(Weekdays, { state: state }), (0, jsx_runtime_1.jsx)(CalendarGridCells, { state: state })] }));
}
function Weekdays({ state }) {
    const weekdays = (0, utils_1.getWeekDays)();
    return ((0, jsx_runtime_1.jsx)("div", { className: b('grid-row'), role: "row", children: weekdays.map((date) => {
            return ((0, jsx_runtime_1.jsx)("div", { className: b('weekday', { weekend: state.isWeekend(date) }), role: "columnheader", "aria-label": date.format('dddd'), children: date.format('dd') }, date.day()));
        }) }));
}
function CalendarGridCells({ state }) {
    const rowsInPeriod = state.mode === 'days' ? 6 : 4;
    const columnsInRow = state.mode === 'days' ? 7 : 3 + (state.mode === 'quarters' ? 1 : 0);
    const days = (0, utils_1.getDaysInPeriod)(state.startDate, state.endDate, state.mode);
    return ((0, jsx_runtime_1.jsx)("div", { className: b('grid-rowgroup', { mode: state.mode }), role: "rowgroup", children: [...new Array(rowsInPeriod).keys()].map((rowIndex) => ((0, jsx_runtime_1.jsxs)("div", { className: b('grid-row'), role: "row", children: [state.mode === 'quarters' ? ((0, jsx_runtime_1.jsx)("span", { role: "rowheader", className: b('grid-rowgroup-header'), children: days[rowIndex * columnsInRow].format('YYYY') })) : null, days
                    .slice(rowIndex * columnsInRow, (rowIndex + 1) * columnsInRow)
                    .map((date) => {
                    return (0, jsx_runtime_1.jsx)(CalendarCell, { date: date, state: state }, date.unix());
                })] }, rowIndex))) }));
}
function CalendarCell({ date, state }) {
    const { cellProps, buttonProps, formattedDate, isDisabled, isSelected, isRangeSelection, isSelectionStart, isSelectionEnd, isOutsideCurrentRange, isUnavailable, isCurrent, isWeekend, } = (0, useCalendarCellProps_1.useCalendarCellProps)(date, state);
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, cellProps, { children: (0, jsx_runtime_1.jsx)("div", Object.assign({}, buttonProps, { className: b('button', {
                disabled: isDisabled,
                selected: isSelected,
                'range-selection': isRangeSelection,
                'selection-start': isSelectionStart,
                'selection-end': isSelectionEnd,
                'out-of-boundary': isOutsideCurrentRange,
                unavailable: isUnavailable,
                current: isCurrent,
                weekend: isWeekend,
            }), children: formattedDate })) })));
}
