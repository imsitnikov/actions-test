"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCalendarState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const date_utils_1 = require("@gravity-ui/date-utils");
const uikit_1 = require("@gravity-ui/uikit");
const dates_1 = require("../../utils/dates");
const useDefaultTimeZone_1 = require("../../utils/useDefaultTimeZone");
const utils_1 = require("../utils");
const defaultModes = {
    days: true,
    months: true,
    quarters: false,
    years: true,
};
function useCalendarState(props) {
    var _a, _b, _c;
    const { disabled, readOnly, modes = defaultModes } = props;
    const [value, setValue] = (0, uikit_1.useControlledState)(props.value, (_a = props.defaultValue) !== null && _a !== void 0 ? _a : null, props.onUpdate);
    const availableModes = utils_1.calendarLayouts.filter((l) => modes[l]);
    const minMode = availableModes[0] || 'days';
    const [mode, setMode] = (0, uikit_1.useControlledState)(props.mode, (_b = props.defaultMode) !== null && _b !== void 0 ? _b : minMode, props.onUpdateMode);
    const currentMode = mode && availableModes.includes(mode) ? mode : minMode;
    const inputTimeZone = (0, useDefaultTimeZone_1.useDefaultTimeZone)(props.value || props.defaultValue || props.focusedValue || props.defaultFocusedValue);
    const timeZone = props.timeZone || inputTimeZone;
    const minValue = react_1.default.useMemo(() => (props.minValue ? props.minValue.timeZone(timeZone) : undefined), [timeZone, props.minValue]);
    const maxValue = react_1.default.useMemo(() => (props.maxValue ? props.maxValue.timeZone(timeZone) : undefined), [timeZone, props.maxValue]);
    const focusedValue = react_1.default.useMemo(() => {
        if (!props.focusedValue) {
            return props.focusedValue;
        }
        return (0, utils_1.constrainValue)(props.focusedValue.timeZone(timeZone), minValue, maxValue);
    }, [props.focusedValue, minValue, maxValue, timeZone]);
    const defaultFocusedValue = react_1.default.useMemo(() => {
        var _a;
        const defaultValue = ((_a = (props.defaultFocusedValue ? props.defaultFocusedValue : value)) === null || _a === void 0 ? void 0 : _a.timeZone(timeZone)) ||
            (0, dates_1.createPlaceholderValue)({ timeZone }).startOf(minMode);
        return (0, utils_1.constrainValue)(defaultValue, minValue, maxValue);
    }, [maxValue, minValue, props.defaultFocusedValue, timeZone, value, minMode]);
    const [focusedDateInner, setFocusedDate] = (0, uikit_1.useControlledState)(focusedValue, defaultFocusedValue, (date) => {
        var _a;
        (_a = props.onFocusUpdate) === null || _a === void 0 ? void 0 : _a.call(props, date.timeZone(inputTimeZone));
    });
    const focusedDate = (_c = focusedDateInner === null || focusedDateInner === void 0 ? void 0 : focusedDateInner.timeZone(timeZone)) !== null && _c !== void 0 ? _c : (0, utils_1.constrainValue)((0, dates_1.createPlaceholderValue)({ timeZone }), minValue, maxValue);
    if (isInvalid(focusedDate, minValue, maxValue)) {
        // If the focused date was moved to an invalid value, it can't be focused, so constrain it.
        setFocusedDate((0, utils_1.constrainValue)(focusedDate, minValue, maxValue));
    }
    function focusCell(date) {
        setFocusedDate((0, utils_1.constrainValue)(date.startOf(currentMode), minValue, maxValue));
    }
    const [isFocused, setFocused] = react_1.default.useState(props.autoFocus || false);
    const startDate = getStartDate(focusedDate, currentMode);
    const endDate = getEndDate(focusedDate, currentMode);
    return {
        disabled,
        readOnly,
        value,
        setValue(date) {
            if (!disabled && !readOnly) {
                let newValue = (0, utils_1.constrainValue)(date, minValue, maxValue);
                if (this.isCellUnavailable(newValue)) {
                    return;
                }
                if (value) {
                    // If there is a date already selected, then we want to keep its time
                    newValue = (0, dates_1.mergeDateTime)(newValue, value.timeZone(timeZone));
                }
                setValue(newValue.timeZone(inputTimeZone));
            }
        },
        timeZone,
        selectDate(date, force = false) {
            if (!disabled) {
                if (!readOnly && (force || this.mode === minMode)) {
                    this.setValue(date.startOf(minMode));
                    if (force && currentMode !== minMode) {
                        setMode(minMode);
                    }
                }
                else {
                    this.zoomIn();
                }
            }
        },
        minValue,
        maxValue,
        focusedDate,
        startDate,
        endDate,
        setFocusedDate(date) {
            focusCell(date);
            setFocused(true);
        },
        focusNextCell() {
            focusCell(focusedDate.add(1, this.mode));
        },
        focusPreviousCell() {
            focusCell(focusedDate.subtract(1, this.mode));
        },
        focusNextRow() {
            if (this.mode === 'days') {
                focusCell(focusedDate.add(1, 'week'));
            }
            else if (this.mode === 'quarters') {
                focusCell(focusedDate.add(1, 'years'));
            }
            else {
                focusCell(focusedDate.add(3, this.mode));
            }
        },
        focusPreviousRow() {
            if (this.mode === 'days') {
                focusCell(focusedDate.subtract(1, 'week'));
            }
            else if (this.mode === 'quarters') {
                focusCell(focusedDate.subtract(1, 'years'));
            }
            else {
                focusCell(focusedDate.subtract(3, this.mode));
            }
        },
        focusNextPage(larger) {
            if (this.mode === 'days') {
                focusCell(focusedDate.add({ months: larger ? 12 : 1 }));
            }
            else if (this.mode === 'quarters') {
                focusCell(focusedDate.add(4, 'years'));
            }
            else {
                focusCell(focusedDate.add(12, this.mode));
            }
        },
        focusPreviousPage(larger) {
            if (this.mode === 'days') {
                focusCell(focusedDate.subtract({ months: larger ? 12 : 1 }));
            }
            else if (this.mode === 'quarters') {
                focusCell(focusedDate.subtract(4, 'years'));
            }
            else {
                focusCell(focusedDate.subtract(12, this.mode));
            }
        },
        focusSectionStart() {
            focusCell(getStartDate(focusedDate, this.mode));
        },
        focusSectionEnd() {
            focusCell(getEndDate(focusedDate, this.mode));
        },
        zoomIn() {
            const nextMode = availableModes[availableModes.indexOf(this.mode) - 1];
            if (nextMode) {
                this.setMode(nextMode);
            }
        },
        zoomOut() {
            const nextMode = availableModes[availableModes.indexOf(this.mode) + 1];
            if (nextMode) {
                this.setMode(nextMode);
            }
        },
        selectFocusedDate() {
            this.selectDate(focusedDate, true);
        },
        isFocused,
        setFocused,
        isInvalid(date) {
            return isInvalid(date, this.minValue, this.maxValue, this.mode);
        },
        isPreviousPageInvalid() {
            const prev = this.startDate.subtract(1, 'day');
            return this.isInvalid(prev);
        },
        isNextPageInvalid() {
            const next = this.endDate.endOf(this.mode).add(1, 'day');
            return this.isInvalid(next);
        },
        isSelected(date) {
            return Boolean(value &&
                date.isSame(value.timeZone(timeZone), currentMode) &&
                !this.isCellDisabled(date));
        },
        isCellUnavailable(date) {
            if (this.mode === minMode) {
                return Boolean(props.isDateUnavailable && props.isDateUnavailable(date));
            }
            else {
                return false;
            }
        },
        isCellFocused(date) {
            return this.isFocused && focusedDate && date.isSame(focusedDate, currentMode);
        },
        isCellDisabled(date) {
            return this.disabled || this.isInvalid(date);
        },
        isWeekend(date) {
            return this.mode === 'days' && [0, 6].includes(date.day());
        },
        isCurrent(date) {
            return (0, date_utils_1.dateTime)({ timeZone }).isSame(date, this.mode);
        },
        mode: currentMode,
        setMode,
        availableModes,
    };
}
exports.useCalendarState = useCalendarState;
function getStartDate(date, mode) {
    if (mode === 'days') {
        return date.startOf('month');
    }
    if (mode === 'months') {
        return date.startOf('year');
    }
    if (mode === 'quarters') {
        const year = Math.floor(date.year() / 4) * 4;
        return date.startOf('year').set('year', year);
    }
    const year = Math.floor(date.year() / 12) * 12;
    return date.startOf('year').set('year', year);
}
function getEndDate(date, mode) {
    if (mode === 'days') {
        return date.endOf('month').startOf('day');
    }
    if (mode === 'months') {
        return date.endOf('year').startOf('month');
    }
    const startDate = getStartDate(date, mode);
    if (mode === 'quarters') {
        return startDate.add(15, 'quarters');
    }
    return startDate.add({ [mode]: 11 });
}
function isInvalid(date, minValue, maxValue, mode = 'days') {
    const constrainedDate = (0, utils_1.constrainValue)(date, minValue, maxValue);
    return !constrainedDate.isSame(date, mode);
}
