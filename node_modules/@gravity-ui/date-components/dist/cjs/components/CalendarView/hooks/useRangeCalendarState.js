"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRangeCalendarState = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
const uikit_1 = require("@gravity-ui/uikit");
const dates_1 = require("../../utils/dates");
const useDefaultTimeZone_1 = require("../../utils/useDefaultTimeZone");
const utils_1 = require("../utils");
const useCalendarState_1 = require("./useCalendarState");
function useRangeCalendarState(props) {
    var _a;
    const { value: valueProp, defaultValue = null, onUpdate } = props, calendarProps = tslib_1.__rest(props, ["value", "defaultValue", "onUpdate"]);
    const [value, setValue] = (0, uikit_1.useControlledState)(valueProp, defaultValue, onUpdate);
    const [anchorDate, setAnchorDateState] = react_1.default.useState();
    const inputTimeZone = (0, useDefaultTimeZone_1.useDefaultTimeZone)((valueProp === null || valueProp === void 0 ? void 0 : valueProp.start) || (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.start) || props.focusedValue || props.defaultFocusedValue);
    const timeZone = props.timeZone || inputTimeZone;
    const calendar = (0, useCalendarState_1.useCalendarState)(Object.assign(Object.assign({}, calendarProps), { value: null, timeZone }));
    const highlightedRange = anchorDate
        ? makeRange(anchorDate, calendar.focusedDate, calendar.mode)
        : (_a = (value &&
            makeRange(value.start.timeZone(timeZone), value.end.timeZone(timeZone), calendar.mode))) !== null && _a !== void 0 ? _a : undefined;
    const minMode = calendar.availableModes[0];
    const handleSetValue = (v) => {
        let { start, end } = v;
        if (value) {
            start = (0, dates_1.mergeDateTime)(start, value.start.timeZone(timeZone));
            end = (0, dates_1.mergeDateTime)(end, value.end.timeZone(timeZone));
        }
        setValue({ start: start.timeZone(inputTimeZone), end: end.timeZone(inputTimeZone) });
    };
    const selectDate = (date, force = false) => {
        if (props.disabled) {
            return;
        }
        if (!force && calendar.mode !== minMode) {
            calendar.zoomIn();
            return;
        }
        if (props.readOnly) {
            return;
        }
        const newDate = (0, utils_1.constrainValue)(date, calendar.minValue, calendar.maxValue);
        if (calendar.isCellUnavailable(newDate)) {
            return;
        }
        if (anchorDate) {
            const range = makeRange(anchorDate, newDate, calendar.mode);
            handleSetValue(range);
            setAnchorDateState(undefined);
        }
        else {
            setAnchorDateState(newDate);
        }
    };
    return Object.assign(Object.assign({}, calendar), { value, setValue: handleSetValue, selectDate,
        anchorDate, setAnchorDate: setAnchorDateState, highlightedRange,
        isSelected(date) {
            if (!highlightedRange) {
                return false;
            }
            return ((date.isSame(highlightedRange.start, this.mode) ||
                date.isAfter(highlightedRange.start)) &&
                (date.isSame(highlightedRange.end, this.mode) ||
                    date.isBefore(highlightedRange.end)));
        },
        highlightDate(date) {
            if (anchorDate) {
                this.setFocusedDate(date);
            }
        } });
}
exports.useRangeCalendarState = useRangeCalendarState;
function makeRange(start, end, mode) {
    if (start.isBefore(end)) {
        return {
            start,
            end: end.endOf(mode),
        };
    }
    return {
        start: end,
        end: start.endOf(mode),
    };
}
