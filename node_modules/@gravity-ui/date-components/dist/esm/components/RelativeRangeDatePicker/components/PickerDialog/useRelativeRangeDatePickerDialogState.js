import React from 'react';
import { dateTimeParse } from '@gravity-ui/date-utils';
import { getValidationResult } from '../../../utils/validation/datePicker';
import { i18n } from './i18n';
export function useRelativeRangeDatePickerDialogState(state, props) {
    var _a, _b, _c, _d;
    const { withApplyButton, allowNullableValues } = props;
    const [start, setStart] = React.useState((_b = (_a = state.value) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : null);
    const [end, setEnd] = React.useState((_d = (_c = state.value) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : null);
    const [innerTimeZone, setTimeZone] = React.useState(state.timeZone);
    const timeZone = withApplyButton ? innerTimeZone : state.timeZone;
    function setStartValue(newValue) {
        setStart(newValue);
        if (!withApplyButton) {
            state.setValue(getRangeValue(newValue, end, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
        }
    }
    function setEndValue(newValue) {
        setEnd(newValue);
        if (!withApplyButton) {
            state.setValue(getRangeValue(start, newValue, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
        }
    }
    function setTimeZoneValue(newTimeZone) {
        setTimeZone(newTimeZone);
        if (!withApplyButton) {
            state.setValue(getRangeValue(start, end, Object.assign(Object.assign({}, props), { timeZone: newTimeZone })), newTimeZone);
        }
    }
    function setRange(newStart, newEnd) {
        setStart(newStart);
        setEnd(newEnd);
        if (!withApplyButton) {
            state.setValue(getRangeValue(newStart, newEnd, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
        }
    }
    function applyValue() {
        state.setValue(getRangeValue(start, end, Object.assign(Object.assign({}, props), { timeZone })), timeZone);
    }
    const validation = React.useMemo(() => getRangeValidationResult(start, end, allowNullableValues, props.minValue, props.maxValue, props.isDateUnavailable, timeZone), [
        allowNullableValues,
        end,
        props.isDateUnavailable,
        props.maxValue,
        props.minValue,
        start,
        timeZone,
    ]);
    return {
        start,
        end,
        timeZone,
        setStart: setStartValue,
        setEnd: setEndValue,
        setRange,
        setTimeZone: setTimeZoneValue,
        applyValue,
        isInvalid: validation.isInvalid,
        startValidation: validation.startValidationResult,
        endValidation: validation.endValidationResult,
    };
}
function getRangeValue(start, end, options = {}) {
    var _a;
    if (!start && !end) {
        return null;
    }
    const { isInvalid } = getRangeValidationResult(start, end, options.allowNullableValues, options.minValue, options.maxValue, options.isDateUnavailable, (_a = options.timeZone) !== null && _a !== void 0 ? _a : 'default');
    if (isInvalid) {
        return null;
    }
    return { start, end };
}
function getRangeValidationResult(start, end, allowNullableValues, minValue, maxValue, isDateUnavailable, timeZone) {
    if (!start && !end) {
        return { isInvalid: false };
    }
    const startDate = start ? dateTimeParse(start.value, { timeZone }) : null;
    const endDate = end ? dateTimeParse(end.value, { timeZone, roundUp: true }) : null;
    const startValidationResult = getValidationResult(startDate, minValue, maxValue, isDateUnavailable, timeZone);
    if (!startDate && !allowNullableValues) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push(i18n('Value is required.'));
    }
    const endValidationResult = getValidationResult(endDate, minValue, maxValue, isDateUnavailable, timeZone);
    if (!endDate && !allowNullableValues) {
        endValidationResult.isInvalid = true;
        endValidationResult.errors.push(i18n('Value is required.'));
    }
    if (startDate && endDate && endDate.isBefore(startDate)) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push(i18n(`"From" can't be after "To".`));
    }
    return {
        isInvalid: startValidationResult.isInvalid || endValidationResult.isInvalid,
        startValidationResult,
        endValidationResult,
    };
}
