import React from 'react';
import { dateTimeParse } from '@gravity-ui/date-utils';
import { useControlledState } from '@gravity-ui/uikit';
import { getValidationResult } from '../../utils/validation/datePicker';
import { i18n } from '../i18n';
export function useRelativeRangeDatePickerState(props) {
    var _a, _b;
    const [value, setValue] = useControlledState(props.value, (_a = props.defaultValue) !== null && _a !== void 0 ? _a : null);
    const [timeZone, setTimeZone] = useControlledState(props.timeZone, (_b = props.defaultTimeZone) !== null && _b !== void 0 ? _b : 'default', props.onUpdateTimeZone);
    const validation = React.useMemo(() => getRangeValidationResult(value, props.allowNullableValues, props.minValue, props.maxValue, props.isDateUnavailable, timeZone), [
        value,
        props.allowNullableValues,
        props.isDateUnavailable,
        props.maxValue,
        props.minValue,
        timeZone,
    ]);
    return Object.assign({ value,
        timeZone,
        setValue(v, tz) {
            var _a;
            setValue(v);
            setTimeZone(tz);
            if (value !== v || (value && timeZone !== tz)) {
                (_a = props.onUpdate) === null || _a === void 0 ? void 0 : _a.call(props, v, tz);
            }
        } }, validation);
}
function getRangeValidationResult(value, allowNullableValues, minValue, maxValue, isDateUnavailable, timeZone) {
    if (!value) {
        return { isInvalid: false, errors: [] };
    }
    const startDate = value.start ? dateTimeParse(value.start.value, { timeZone }) : null;
    const endDate = value.end ? dateTimeParse(value.end.value, { timeZone, roundUp: true }) : null;
    const startValidationResult = getValidationResult(startDate, minValue, maxValue, isDateUnavailable, timeZone, i18n('"From"'));
    if (!startDate && !allowNullableValues) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push(i18n('"From" is required.'));
    }
    const endValidationResult = getValidationResult(endDate, minValue, maxValue, isDateUnavailable, timeZone, i18n('"To"'));
    if (!endDate && !allowNullableValues) {
        endValidationResult.isInvalid = true;
        endValidationResult.errors.push(i18n('"To" is required.'));
    }
    if (startDate && endDate && endDate.isBefore(startDate)) {
        startValidationResult.isInvalid = true;
        startValidationResult.errors.push(i18n(`"From" can't be after "To".`));
    }
    return {
        isInvalid: startValidationResult.isInvalid || endValidationResult.isInvalid,
        errors: startValidationResult.errors.concat(endValidationResult.errors),
    };
}
