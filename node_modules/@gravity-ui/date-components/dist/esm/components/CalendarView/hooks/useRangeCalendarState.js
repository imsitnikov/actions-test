import { __rest } from "tslib";
import React from 'react';
import { useControlledState } from '@gravity-ui/uikit';
import { mergeDateTime } from '../../utils/dates';
import { useDefaultTimeZone } from '../../utils/useDefaultTimeZone';
import { constrainValue } from '../utils';
import { useCalendarState } from './useCalendarState';
export function useRangeCalendarState(props) {
    var _a;
    const { value: valueProp, defaultValue = null, onUpdate } = props, calendarProps = __rest(props, ["value", "defaultValue", "onUpdate"]);
    const [value, setValue] = useControlledState(valueProp, defaultValue, onUpdate);
    const [anchorDate, setAnchorDateState] = React.useState();
    const inputTimeZone = useDefaultTimeZone((valueProp === null || valueProp === void 0 ? void 0 : valueProp.start) || (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.start) || props.focusedValue || props.defaultFocusedValue);
    const timeZone = props.timeZone || inputTimeZone;
    const calendar = useCalendarState(Object.assign(Object.assign({}, calendarProps), { value: null, timeZone }));
    const highlightedRange = anchorDate
        ? makeRange(anchorDate, calendar.focusedDate, calendar.mode)
        : (_a = (value &&
            makeRange(value.start.timeZone(timeZone), value.end.timeZone(timeZone), calendar.mode))) !== null && _a !== void 0 ? _a : undefined;
    const minMode = calendar.availableModes[0];
    const handleSetValue = (v) => {
        let { start, end } = v;
        if (value) {
            start = mergeDateTime(start, value.start.timeZone(timeZone));
            end = mergeDateTime(end, value.end.timeZone(timeZone));
        }
        setValue({ start: start.timeZone(inputTimeZone), end: end.timeZone(inputTimeZone) });
    };
    const selectDate = (date, force = false) => {
        if (props.disabled) {
            return;
        }
        if (!force && calendar.mode !== minMode) {
            calendar.zoomIn();
            return;
        }
        if (props.readOnly) {
            return;
        }
        const newDate = constrainValue(date, calendar.minValue, calendar.maxValue);
        if (calendar.isCellUnavailable(newDate)) {
            return;
        }
        if (anchorDate) {
            const range = makeRange(anchorDate, newDate, calendar.mode);
            handleSetValue(range);
            setAnchorDateState(undefined);
        }
        else {
            setAnchorDateState(newDate);
        }
    };
    return Object.assign(Object.assign({}, calendar), { value, setValue: handleSetValue, selectDate,
        anchorDate, setAnchorDate: setAnchorDateState, highlightedRange,
        isSelected(date) {
            if (!highlightedRange) {
                return false;
            }
            return ((date.isSame(highlightedRange.start, this.mode) ||
                date.isAfter(highlightedRange.start)) &&
                (date.isSame(highlightedRange.end, this.mode) ||
                    date.isBefore(highlightedRange.end)));
        },
        highlightDate(date) {
            if (anchorDate) {
                this.setFocusedDate(date);
            }
        } });
}
function makeRange(start, end, mode) {
    if (start.isBefore(end)) {
        return {
            start,
            end: end.endOf(mode),
        };
    }
    return {
        start: end,
        end: start.endOf(mode),
    };
}
