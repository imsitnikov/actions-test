import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from 'react';
import { ChevronLeft, ChevronRight } from '@gravity-ui/icons';
import { ArrowToggle, Button } from '@gravity-ui/uikit';
import { block } from '../../utils/cn';
import { useCalendarCellProps } from './hooks/useCalendarCellProps';
import { useCalendarGridProps } from './hooks/useCalendarGridProps';
import { useCalendarProps } from './hooks/useCalendarProps';
import { calendarLayouts, getDaysInPeriod, getWeekDays } from './utils';
import './Calendar.css';
const b = block('calendar');
export const CalendarView = React.forwardRef(function Calendar(props, ref) {
    const { state } = props;
    const { calendarProps, modeButtonProps, nextButtonProps, previousButtonProps } = useCalendarProps(props, state);
    React.useImperativeHandle(ref, () => ({
        focus() {
            state.setFocused(true);
        },
    }));
    return (_jsxs("div", Object.assign({}, calendarProps, { className: b({ size: props.size }), children: [_jsxs("div", { className: b('header'), children: [_jsx(Button, Object.assign({}, modeButtonProps, { view: "flat", size: props.size, children: state.availableModes.indexOf(state.mode) + 1 ===
                            state.availableModes.length ? (_jsx("span", { className: b('mode-label', b(`years-label`)), children: modeButtonProps.children }, "label")) : ([
                            _jsx("span", { className: b('mode-label'), children: modeButtonProps.children }, "label"),
                            _jsx(Button.Icon, { children: _jsx(ArrowToggle, { direction: "bottom" }) }, "icon"),
                        ]) })), _jsxs("div", { className: b('controls'), children: [_jsx(Button, Object.assign({}, previousButtonProps, { view: "flat", size: props.size, children: _jsx(Button.Icon, { children: _jsx(ChevronLeft, { className: b('control-icon') }) }) })), _jsx(Button, Object.assign({}, nextButtonProps, { view: "flat", size: props.size, children: _jsx(Button.Icon, { children: _jsx(ChevronRight, { className: b('control-icon') }) }) }))] })] }), _jsx(CalendarGrid, { state: state })] })));
});
function CalendarGrid({ state }) {
    const [prevState, setPrevState] = React.useState(() => (Object.assign(Object.assign({}, state), { isFocused: false })));
    const modeChanged = state.mode !== prevState.mode;
    const startDateChanged = !state.startDate.isSame(prevState.startDate, 'days');
    let animation;
    if (modeChanged) {
        if (calendarLayouts.indexOf(prevState.mode) > calendarLayouts.indexOf(state.mode)) {
            animation = 'zoom-out';
        }
        else {
            animation = 'zoom-in';
        }
    }
    else if (startDateChanged) {
        if (state.startDate.isBefore(prevState.startDate)) {
            animation = 'forward';
        }
        else {
            animation = 'backward';
        }
    }
    const { gridProps } = useCalendarGridProps(state);
    return (_jsxs("div", Object.assign({ className: b('grid') }, gridProps, { children: [animation && (_jsx(Content, { className: b('previous-state'), state: prevState, animation: animation })), _jsx(Content, { className: b('current-state'), state: state, animation: animation, onAnimationEnd: () => {
                    setPrevState(Object.assign(Object.assign({}, state), { isFocused: false }));
                } }, "current")] })));
}
function Content({ className, state, animation, onAnimationEnd }) {
    return (_jsxs("div", { className: b('content', { animation }, className), onAnimationEnd: onAnimationEnd, role: "presentation", children: [state.mode === 'days' && _jsx(Weekdays, { state: state }), _jsx(CalendarGridCells, { state: state })] }));
}
function Weekdays({ state }) {
    const weekdays = getWeekDays();
    return (_jsx("div", { className: b('grid-row'), role: "row", children: weekdays.map((date) => {
            return (_jsx("div", { className: b('weekday', { weekend: state.isWeekend(date) }), role: "columnheader", "aria-label": date.format('dddd'), children: date.format('dd') }, date.day()));
        }) }));
}
function CalendarGridCells({ state }) {
    const rowsInPeriod = state.mode === 'days' ? 6 : 4;
    const columnsInRow = state.mode === 'days' ? 7 : 3 + (state.mode === 'quarters' ? 1 : 0);
    const days = getDaysInPeriod(state.startDate, state.endDate, state.mode);
    return (_jsx("div", { className: b('grid-rowgroup', { mode: state.mode }), role: "rowgroup", children: [...new Array(rowsInPeriod).keys()].map((rowIndex) => (_jsxs("div", { className: b('grid-row'), role: "row", children: [state.mode === 'quarters' ? (_jsx("span", { role: "rowheader", className: b('grid-rowgroup-header'), children: days[rowIndex * columnsInRow].format('YYYY') })) : null, days
                    .slice(rowIndex * columnsInRow, (rowIndex + 1) * columnsInRow)
                    .map((date) => {
                    return _jsx(CalendarCell, { date: date, state: state }, date.unix());
                })] }, rowIndex))) }));
}
function CalendarCell({ date, state }) {
    const { cellProps, buttonProps, formattedDate, isDisabled, isSelected, isRangeSelection, isSelectionStart, isSelectionEnd, isOutsideCurrentRange, isUnavailable, isCurrent, isWeekend, } = useCalendarCellProps(date, state);
    return (_jsx("div", Object.assign({}, cellProps, { children: _jsx("div", Object.assign({}, buttonProps, { className: b('button', {
                disabled: isDisabled,
                selected: isSelected,
                'range-selection': isRangeSelection,
                'selection-start': isSelectionStart,
                'selection-end': isSelectionEnd,
                'out-of-boundary': isOutsideCurrentRange,
                unavailable: isUnavailable,
                current: isCurrent,
                weekend: isWeekend,
            }), children: formattedDate })) })));
}
