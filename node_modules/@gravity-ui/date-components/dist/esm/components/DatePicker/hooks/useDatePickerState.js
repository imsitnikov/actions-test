import React from 'react';
import { useControlledState } from '@gravity-ui/uikit';
import { useDateFieldState } from '../../DateField';
import { createPlaceholderValue, mergeDateTime } from '../../utils/dates';
import { useDefaultTimeZone } from '../../utils/useDefaultTimeZone';
export function useDatePickerState(props) {
    var _a;
    const { disabled, readOnly } = props;
    const [isOpen, setOpen] = React.useState(false);
    const [value, setValue] = useControlledState(props.value, (_a = props.defaultValue) !== null && _a !== void 0 ? _a : null, props.onUpdate);
    const [selectedDateInner, setSelectedDate] = React.useState(null);
    const [selectedTimeInner, setSelectedTime] = React.useState(null);
    const inputTimeZone = useDefaultTimeZone(props.value || props.defaultValue || props.placeholderValue);
    const timeZone = props.timeZone || inputTimeZone;
    let selectedDate = selectedDateInner;
    let selectedTime = selectedTimeInner;
    const format = props.format || 'L';
    const commitValue = (date, time) => {
        if (disabled || readOnly) {
            return;
        }
        setValue(mergeDateTime(date, time).timeZone(inputTimeZone));
        setSelectedDate(null);
        setSelectedTime(null);
    };
    const dateFieldState = useDateFieldState({
        value,
        onUpdate(date) {
            if (date) {
                commitValue(date, date);
            }
            else {
                setValue(null);
            }
        },
        disabled,
        readOnly,
        validationState: props.validationState,
        minValue: props.minValue,
        maxValue: props.maxValue,
        isDateUnavailable: props.isDateUnavailable,
        format,
        placeholderValue: props.placeholderValue,
        timeZone,
    });
    const timeFormat = React.useMemo(() => {
        const hasSeconds = dateFieldState.sections.some((s) => s.type === 'second');
        return hasSeconds ? 'LTS' : 'LT';
    }, [dateFieldState.sections]);
    if (value) {
        selectedDate = value.timeZone(timeZone);
        if (dateFieldState.hasTime) {
            selectedTime = value.timeZone(timeZone);
        }
    }
    // Intercept setValue to make sure the Time section is not changed by date selection in Calendar
    const selectDate = (newValue) => {
        if (disabled || readOnly) {
            return;
        }
        const shouldClose = !dateFieldState.hasTime;
        if (dateFieldState.hasTime) {
            if (selectedTime || shouldClose) {
                commitValue(newValue, selectedTime || newValue);
            }
            else {
                setSelectedDate(newValue);
            }
        }
        else {
            commitValue(newValue, newValue);
        }
        if (shouldClose) {
            setOpen(false);
        }
    };
    const selectTime = (newValue) => {
        if (disabled || readOnly) {
            return;
        }
        const newTime = newValue !== null && newValue !== void 0 ? newValue : createPlaceholderValue({
            placeholderValue: props.placeholderValue,
            timeZone,
        });
        if (selectedDate) {
            commitValue(selectedDate, newTime);
        }
        else {
            setSelectedTime(newTime);
        }
    };
    if (dateFieldState.hasTime && !selectedTime) {
        selectedTime = dateFieldState.displayValue;
    }
    return {
        value,
        setValue(newDate) {
            if (props.readOnly || props.disabled) {
                return;
            }
            if (newDate) {
                setValue(newDate.timeZone(inputTimeZone));
            }
            else {
                setValue(null);
            }
        },
        dateValue: selectedDate,
        timeValue: selectedTime,
        setDateValue: selectDate,
        setTimeValue: selectTime,
        disabled,
        readOnly,
        format,
        hasDate: dateFieldState.hasDate,
        hasTime: dateFieldState.hasTime,
        timeFormat,
        timeZone,
        isOpen,
        setOpen(newIsOpen) {
            if (!newIsOpen && !value && selectedDate && dateFieldState.hasTime) {
                commitValue(selectedDate, selectedTime ||
                    createPlaceholderValue({
                        placeholderValue: props.placeholderValue,
                        timeZone: inputTimeZone,
                    }));
            }
            setOpen(newIsOpen);
        },
        dateFieldState,
    };
}
