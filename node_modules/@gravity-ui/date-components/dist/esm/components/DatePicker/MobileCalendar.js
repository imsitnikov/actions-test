import { jsx as _jsx } from "react/jsx-runtime";
import { dateTime } from '@gravity-ui/date-utils';
import { Calendar as CalendarIcon } from '@gravity-ui/icons';
import { Icon } from '@gravity-ui/uikit';
import { block } from '../../utils/cn';
import { createPlaceholderValue, mergeDateTime } from '../utils/dates';
import { getButtonSizeForInput } from '../utils/getButtonSizeForInput';
import './MobileCalendar.css';
const b = block('mobile-calendar');
export function MobileCalendar({ props, state }) {
    var _a, _b;
    let type = 'date';
    if (state.hasTime && state.hasDate) {
        type = 'datetime-local';
    }
    else if (state.hasTime) {
        type = 'time';
    }
    return (_jsx("input", { className: b('input'), disabled: props.disabled, type: type, value: formatNative(state.dateFieldState.displayValue, type), id: props.id, min: formatNative((_a = props.minValue) === null || _a === void 0 ? void 0 : _a.timeZone(state.timeZone), type), max: formatNative((_b = props.maxValue) === null || _b === void 0 ? void 0 : _b.timeZone(state.timeZone), type), tabIndex: -1, onChange: (e) => {
            var _a, _b;
            if (props.readOnly) {
                return;
            }
            const newValue = e.target.value;
            if (newValue) {
                const localDate = dateTime({
                    input: newValue,
                    format: getDateFormat(type),
                    timeZone: 'system',
                }).timeZone(state.timeZone, true);
                let newDate = state.hasDate
                    ? localDate
                    : createPlaceholderValue({
                        placeholderValue: (_a = props.placeholderValue) === null || _a === void 0 ? void 0 : _a.timeZone(state.timeZone),
                        timeZone: state.timeZone,
                    });
                if (state.hasTime) {
                    newDate = mergeDateTime(newDate, localDate);
                }
                else if (state.value) {
                    newDate = mergeDateTime(newDate, state.value.timeZone(state.timeZone));
                }
                else {
                    newDate = mergeDateTime(newDate, createPlaceholderValue({
                        placeholderValue: (_b = props.placeholderValue) === null || _b === void 0 ? void 0 : _b.timeZone(state.timeZone),
                        timeZone: state.timeZone,
                    }));
                }
                state.setValue(newDate);
            }
            else {
                state.setValue(null);
            }
        } }));
}
export function MobileCalendarIcon({ props }) {
    return (_jsx("span", { className: b({ size: getButtonSizeForInput(props.size) }), children: _jsx("span", { className: b('button'), children: _jsx(Icon, { data: CalendarIcon }) }) }));
}
function getDateFormat(type) {
    switch (type) {
        case 'time': {
            return 'HH:mm';
        }
        case 'datetime-local': {
            return 'YYYY-MM-DDTHH:mm';
        }
        default: {
            return 'YYYY-MM-DD';
        }
    }
}
function formatNative(date, type) {
    if (!date) {
        return '';
    }
    const format = getDateFormat(type);
    return date.format(format);
}
