/* eslint-disable complexity */
import React from 'react';
import { isValid } from '@gravity-ui/date-utils';
import { useControlledState } from '@gravity-ui/uikit';
import { useBaseDateFieldState } from '../../DateField';
import { EDITABLE_SEGMENTS, addSegment, isAllSegmentsValid, parseDateFromString, setSegment, useFormatSections, } from '../../DateField/utils';
import { isInvalid } from '../../utils/dates';
import { useDefaultTimeZone } from '../../utils/useDefaultTimeZone';
import { createPlaceholderRangeValue, getRangeEditableSections, isValidRange } from '../utils';
const RANGE_FORMAT_DELIMITER = ' â€” ';
export function useRangeDateFieldState(props) {
    var _a, _b, _c, _d, _e;
    const [value, setRange] = useControlledState(props.value, props.defaultValue || null, props.onUpdate);
    const inputTimeZone = useDefaultTimeZone(((_a = props.value) === null || _a === void 0 ? void 0 : _a.start) || ((_b = props.defaultValue) === null || _b === void 0 ? void 0 : _b.start) || props.placeholderValue);
    const timeZone = props.timeZone || inputTimeZone;
    const handleUpdateRange = (v) => {
        setRange(v ? { start: v.start.timeZone(inputTimeZone), end: v.end.timeZone(inputTimeZone) } : v);
    };
    const [placeholderDate, setPlaceholderDate] = React.useState(() => {
        return createPlaceholderRangeValue({
            placeholderValue: props.placeholderValue,
            timeZone,
        });
    });
    const format = props.format || 'L';
    const delimiter = (_c = props.delimiter) !== null && _c !== void 0 ? _c : RANGE_FORMAT_DELIMITER;
    const sections = useFormatSections(format);
    const allSegments = React.useMemo(() => {
        return sections
            .filter((seg) => EDITABLE_SEGMENTS[seg.type])
            .reduce((p, seg) => (Object.assign(Object.assign({}, p), { [seg.type]: true })), {});
    }, [sections]);
    // eslint-disable-next-line prefer-const
    let [validSegments, setValidSegments] = React.useState(() => (value ? { start: Object.assign({}, allSegments), end: Object.assign({}, allSegments) } : { start: {}, end: {} }));
    if (value &&
        (!isAllSegmentsValid(allSegments, validSegments.start) ||
            !isAllSegmentsValid(allSegments, validSegments.end))) {
        setValidSegments({ start: Object.assign({}, allSegments), end: Object.assign({}, allSegments) });
    }
    if (!value &&
        isAllSegmentsValid(allSegments, validSegments.start) &&
        Object.keys(validSegments.start).length === Object.keys(allSegments).length &&
        isAllSegmentsValid(allSegments, validSegments.end) &&
        Object.keys(validSegments.end).length === Object.keys(allSegments).length) {
        validSegments = { start: {}, end: {} };
        setValidSegments(validSegments);
        setPlaceholderDate(createPlaceholderRangeValue({
            placeholderValue: props.placeholderValue,
            timeZone,
        }));
    }
    const displayValue = value &&
        isValid(value.start) &&
        isValid(value.end) &&
        Object.keys(validSegments.start).length >= Object.keys(allSegments).length &&
        Object.keys(validSegments.end).length >= Object.keys(allSegments).length
        ? { start: value.start.timeZone(timeZone), end: value.end.timeZone(timeZone) }
        : {
            start: placeholderDate.start.timeZone(timeZone),
            end: placeholderDate.end.timeZone(timeZone),
        };
    const sectionsState = useSectionsState(sections, displayValue, validSegments, delimiter);
    const [selectedSections, setSelectedSections] = React.useState(-1);
    const selectedSectionIndexes = React.useMemo(() => {
        if (selectedSections === -1) {
            return null;
        }
        if (selectedSections === 'all') {
            return {
                startIndex: 0,
                endIndex: sectionsState.editableSections.length - 1,
            };
        }
        if (typeof selectedSections === 'number') {
            return { startIndex: selectedSections, endIndex: selectedSections };
        }
        if (typeof selectedSections === 'string') {
            const selectedSectionIndex = sectionsState.editableSections.findIndex((section) => section.type === selectedSections);
            return { startIndex: selectedSectionIndex, endIndex: selectedSectionIndex };
        }
        return selectedSections;
    }, [selectedSections, sectionsState.editableSections]);
    function setValue(newValue) {
        if (props.disabled || props.readOnly) {
            return;
        }
        if (isAllSegmentsValid(allSegments, validSegments.start) &&
            isAllSegmentsValid(allSegments, validSegments.end)) {
            if (!value || !(newValue.start.isSame(value.start) && newValue.end.isSame(value.end))) {
                handleUpdateRange(newValue);
            }
        }
        else {
            if (value) {
                handleUpdateRange(null);
            }
            setPlaceholderDate(newValue);
        }
    }
    function markValid(portion, part) {
        validSegments[portion][part] = true;
        if (validSegments[portion].day &&
            validSegments[portion].month &&
            validSegments[portion].year &&
            allSegments.weekday) {
            validSegments[portion].weekday = true;
        }
        if (validSegments[portion].hour && allSegments.dayPeriod) {
            validSegments[portion].dayPeriod = true;
        }
        setValidSegments(Object.assign(Object.assign({}, validSegments), { [portion]: Object.assign({}, validSegments[portion]) }));
    }
    function setSection(sectionIndex, amount) {
        const portion = sectionIndex <= sections.length ? 'start' : 'end';
        const section = sectionsState.editableSections[sectionIndex];
        markValid(portion, section.type);
        setValue(Object.assign(Object.assign({}, displayValue), { [portion]: setSegment(section, displayValue[portion], amount) }));
    }
    function adjustSection(sectionIndex, amount) {
        const section = sectionsState.editableSections[sectionIndex];
        const portion = sectionIndex <= sections.length ? 'start' : 'end';
        if (validSegments[portion][section.type]) {
            setValue(Object.assign(Object.assign({}, displayValue), { [portion]: addSegment(section, displayValue[portion], amount) }));
        }
        else {
            markValid(portion, section.type);
            if (Object.keys(validSegments[portion]).length >= Object.keys(allSegments).length) {
                setValue(displayValue);
            }
        }
    }
    function flushValidSection(sectionIndex) {
        const portion = sectionIndex <= sections.length ? 'start' : 'end';
        delete validSegments[portion][sectionsState.editableSections[sectionIndex].type];
        setValidSegments(Object.assign(Object.assign({}, validSegments), { [portion]: Object.assign({}, validSegments[portion]) }));
    }
    function flushAllValidSections() {
        validSegments = { start: {}, end: {} };
        setValidSegments({ start: {}, end: {} });
    }
    function getSectionValue(sectionIndex) {
        const portion = sectionIndex <= sections.length ? 'start' : 'end';
        return displayValue[portion];
    }
    function setSectionValue(sectionIndex, currentValue) {
        const portion = sectionIndex <= sections.length ? 'start' : 'end';
        setValue(Object.assign(Object.assign({}, displayValue), { [portion]: currentValue }));
    }
    function createPlaceholder() {
        return createPlaceholderRangeValue({
            placeholderValue: props.placeholderValue,
            timeZone,
        });
    }
    function setValueFromString(str) {
        var _a, _b;
        const list = str.split(delimiter);
        const start = parseDateFromString((_a = list === null || list === void 0 ? void 0 : list[0]) === null || _a === void 0 ? void 0 : _a.trim(), format, timeZone);
        const end = parseDateFromString((_b = list === null || list === void 0 ? void 0 : list[1]) === null || _b === void 0 ? void 0 : _b.trim(), format, timeZone);
        const range = { start, end };
        if (isValid(range.start) && isValid(range.end)) {
            handleUpdateRange(range);
            return true;
        }
        return false;
    }
    const validationState = props.validationState ||
        (isInvalid(value === null || value === void 0 ? void 0 : value.start, props.minValue, props.maxValue) ? 'invalid' : undefined) ||
        (isInvalid(value === null || value === void 0 ? void 0 : value.end, props.minValue, props.maxValue) ? 'invalid' : undefined) ||
        (value && !isValidRange(value) ? 'invalid' : undefined) ||
        (value && ((_d = props.isDateUnavailable) === null || _d === void 0 ? void 0 : _d.call(props, value.start)) ? 'invalid' : undefined) ||
        (value && ((_e = props.isDateUnavailable) === null || _e === void 0 ? void 0 : _e.call(props, value.end)) ? 'invalid' : undefined);
    return useBaseDateFieldState({
        value,
        displayValue,
        placeholderValue: props.placeholderValue,
        timeZone,
        validationState,
        editableSections: sectionsState.editableSections,
        readOnly: props.readOnly,
        disabled: props.disabled,
        selectedSectionIndexes,
        selectedSections,
        isEmpty: Object.keys(validSegments.start).length === 0 &&
            Object.keys(validSegments.end).length === 0,
        flushAllValidSections,
        flushValidSection,
        setSelectedSections,
        setValue,
        setDate: handleUpdateRange,
        adjustSection,
        setSection,
        getSectionValue,
        setSectionValue,
        createPlaceholder,
        setValueFromString,
    });
}
function useSectionsState(sections, value, validSegments, delimiter) {
    const [state, setState] = React.useState(() => {
        return {
            value,
            sections,
            validSegments,
            delimiter,
            editableSections: getRangeEditableSections(sections, value, validSegments, delimiter),
        };
    });
    if (sections !== state.sections ||
        validSegments !== state.validSegments ||
        !(value.start.isSame(state.value.start) && value.end.isSame(state.value.end)) ||
        delimiter !== state.delimiter) {
        setState({
            value,
            sections,
            validSegments,
            delimiter,
            editableSections: getRangeEditableSections(sections, value, validSegments, delimiter),
        });
    }
    return state;
}
