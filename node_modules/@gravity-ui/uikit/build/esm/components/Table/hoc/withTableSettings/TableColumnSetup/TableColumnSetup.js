import React from 'react';
import { Gear, Grip, Lock } from '@gravity-ui/icons';
import { DragDropContext, Draggable, Droppable } from 'react-beautiful-dnd';
import { useUniqId } from '../../../../../hooks';
import { createOnKeyDownHandler } from '../../../../../hooks/useActionHandlers/useActionHandlers';
import { Button } from '../../../../Button';
import { Icon } from '../../../../Icon';
import { TreeSelect } from '../../../../TreeSelect/TreeSelect';
import { Flex } from '../../../../layout/Flex/Flex';
import { ListContainerView, ListItemView } from '../../../../useList';
import { block } from '../../../../utils/cn';
import i18n from './i18n';
import './TableColumnSetup.css';
const b = block('inner-table-column-setup');
const controlsCn = b('controls');
const reorderArray = (list, startIndex, endIndex) => {
    const result = [...list];
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);
    return result;
};
const prepareStickyState = (itemsById, visibleFlattenIds) => {
    let lastStickyStartIdx = 0;
    for (; lastStickyStartIdx !== visibleFlattenIds.length; lastStickyStartIdx++) {
        const visibleFlattenId = visibleFlattenIds[lastStickyStartIdx];
        const item = itemsById[visibleFlattenId];
        if ((item === null || item === void 0 ? void 0 : item.sticky) !== 'left' && (item === null || item === void 0 ? void 0 : item.sticky) !== 'start') {
            break;
        }
    }
    let firstStickyEndIdx = visibleFlattenIds.length;
    for (; firstStickyEndIdx !== 0; firstStickyEndIdx--) {
        const visibleFlattenId = visibleFlattenIds[firstStickyEndIdx - 1];
        const item = itemsById[visibleFlattenId];
        if ((item === null || item === void 0 ? void 0 : item.sticky) !== 'right' && (item === null || item === void 0 ? void 0 : item.sticky) !== 'end') {
            break;
        }
    }
    return {
        stickyStartItemIdList: visibleFlattenIds.slice(0, lastStickyStartIdx),
        sortableItemIdList: visibleFlattenIds.slice(lastStickyStartIdx, firstStickyEndIdx),
        stickyEndItemIdList: visibleFlattenIds.slice(firstStickyEndIdx),
    };
};
const prepareValue = (tableColumnItems) => {
    const selectedIds = [];
    tableColumnItems.forEach(({ id, isSelected }) => {
        if (isSelected) {
            selectedIds.push(id);
        }
    });
    return selectedIds;
};
const RENDER_DRAG_DISABLED_CONTAINER_PROPS = { isDragDisabled: true };
const useDndRenderContainer = ({ onDragEnd, renderControls }) => {
    const uniqId = useUniqId();
    const dndRenderContainer = ({ renderItem, visibleFlattenIds, itemsById, containerRef, id, className, }) => {
        const renderDndActiveItem = (provided, snapshot, rubric) => {
            const renderContainerProps = {
                provided,
                snapshot,
            };
            return renderItem(visibleFlattenIds[rubric.source.index], rubric.source.index, renderContainerProps);
        };
        const { stickyStartItemIdList, sortableItemIdList, stickyEndItemIdList } = prepareStickyState(itemsById, visibleFlattenIds);
        const stickyStartItemList = stickyStartItemIdList.map((visibleFlattenId, idx) => {
            return renderItem(visibleFlattenId, idx, RENDER_DRAG_DISABLED_CONTAINER_PROPS);
        });
        const sortableItemList = sortableItemIdList.map((visibleFlattenId, idx) => {
            return renderItem(visibleFlattenId, idx + stickyStartItemIdList.length);
        });
        const stickyEndItemList = stickyEndItemIdList.map((visibleFlattenId, idx) => {
            return renderItem(visibleFlattenId, stickyStartItemList.length + sortableItemList.length + idx, RENDER_DRAG_DISABLED_CONTAINER_PROPS);
        });
        return (React.createElement(React.Fragment, null,
            React.createElement(ListContainerView, { ref: containerRef, id: id, className: className },
                stickyStartItemList,
                React.createElement(DragDropContext, { onDragEnd: onDragEnd },
                    React.createElement(Droppable, { droppableId: uniqId, renderClone: renderDndActiveItem }, (droppableProvided) => {
                        return (React.createElement("div", Object.assign({}, droppableProvided.droppableProps, { ref: droppableProvided.innerRef }),
                            sortableItemList,
                            droppableProvided.placeholder));
                    })),
                stickyEndItemList),
            React.createElement("div", { className: controlsCn }, renderControls())));
    };
    return dndRenderContainer;
};
const useDndRenderItem = (sortable) => {
    const renderDndItem = ({ data: item, props, index, renderContainerProps, }) => {
        const isDragDisabled = sortable === false || (renderContainerProps === null || renderContainerProps === void 0 ? void 0 : renderContainerProps.isDragDisabled) === true;
        const endSlot = isDragDisabled ? undefined : React.createElement(Icon, { data: Grip, size: 16 });
        const hasSelectionIcon = !item.isRequired;
        const startSlot = item.isRequired ? React.createElement(Icon, { data: Lock }) : undefined;
        const selected = item.isRequired ? false : props.selected;
        const commonProps = Object.assign(Object.assign({}, props), { selected,
            startSlot,
            hasSelectionIcon,
            endSlot });
        if (isDragDisabled) {
            return React.createElement(ListItemView, Object.assign({}, commonProps, { key: commonProps.id }));
        }
        const renderItem = (provided, snapshot) => (React.createElement(ListItemView, Object.assign({}, commonProps, provided.draggableProps, provided.dragHandleProps, { ref: provided.innerRef, dragging: snapshot.isDragging })));
        if ((renderContainerProps === null || renderContainerProps === void 0 ? void 0 : renderContainerProps.provided) && renderContainerProps.snapshot) {
            return renderItem(renderContainerProps.provided, renderContainerProps.snapshot);
        }
        return (React.createElement(Draggable, { draggableId: props.id, index: index, key: `item-key-${props.id}`, isDragDisabled: isDragDisabled }, renderItem));
    };
    return renderDndItem;
};
const mapItemDataToProps = (item) => {
    return {
        title: item.title,
    };
};
export const TableColumnSetup = (props) => {
    const { renderSwitcher, popupWidth, popupPlacement, items: propsItems, onUpdate: propsOnUpdate, sortable, renderControls, className, defaultItems = propsItems, showResetButton: propsShowResetButton, } = props;
    const [open, setOpen] = React.useState(false);
    const [items, setItems] = React.useState(propsItems);
    const [prevPropsItems, setPrevPropsItems] = React.useState(propsItems);
    if (propsItems !== prevPropsItems) {
        setPrevPropsItems(propsItems);
        setItems(propsItems);
    }
    const onApply = () => {
        const newSettings = items.map(({ id, isSelected }) => ({ id, isSelected }));
        propsOnUpdate(newSettings);
        setOpen(false);
    };
    const DefaultApplyButton = () => (React.createElement(Button, { view: "action", width: "max", onClick: onApply }, i18n('button_apply')));
    const onDragEnd = ({ destination, source }) => {
        if ((destination === null || destination === void 0 ? void 0 : destination.index) !== undefined && (destination === null || destination === void 0 ? void 0 : destination.index) !== source.index) {
            setItems((prevItems) => {
                return reorderArray(prevItems, source.index, destination.index);
            });
        }
    };
    const showResetButton = typeof propsShowResetButton === 'function'
        ? propsShowResetButton(items)
        : propsShowResetButton;
    const dndRenderContainer = useDndRenderContainer({
        onDragEnd,
        renderControls: () => renderControls ? (renderControls({ DefaultApplyButton, onApply })) : (React.createElement(Flex, { gapRow: 1, direction: "column", className: controlsCn },
            showResetButton && (React.createElement(Button, { onClick: () => {
                    setItems(defaultItems);
                }, width: "max" }, i18n('button_reset'))),
            React.createElement(DefaultApplyButton, null))),
    });
    const dndRenderItem = useDndRenderItem(sortable);
    const renderControl = ({ toggleOpen }) => {
        const onKeyDown = createOnKeyDownHandler(toggleOpen);
        return ((renderSwitcher === null || renderSwitcher === void 0 ? void 0 : renderSwitcher({ onClick: toggleOpen, onKeyDown })) || (React.createElement(Button, { onClick: toggleOpen, extraProps: { onKeyDown } },
            React.createElement(Icon, { data: Gear }),
            i18n('button_switcher'))));
    };
    const onOpenChange = (open) => {
        setOpen(open);
        if (open === false) {
            setItems(propsItems);
        }
    };
    const onUpdate = (selectedItemsIds) => {
        setItems((prevItems) => {
            return prevItems.map((item) => (Object.assign(Object.assign({}, item), { isSelected: item.isRequired || selectedItemsIds.includes(item.id) })));
        });
    };
    const value = React.useMemo(() => prepareValue(items), [items]);
    return (React.createElement(TreeSelect, { className: b(null, className), mapItemDataToProps: mapItemDataToProps, multiple: true, size: "l", open: open, value: value, items: items, onUpdate: onUpdate, popupWidth: popupWidth, onOpenChange: onOpenChange, placement: popupPlacement, renderContainer: dndRenderContainer, renderControl: renderControl, renderItem: dndRenderItem }));
};
