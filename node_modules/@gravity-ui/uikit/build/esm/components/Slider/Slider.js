import React from 'react';
import debounce from 'lodash/debounce';
import { useDirection } from '../theme';
import { block } from '../utils/cn';
import { BaseSlider } from './BaseSlider/BaseSlider';
import { SliderTooltip } from './SliderTooltip/SliderTooltip';
import { prepareSliderInnerState } from './utils';
import './Slider.css';
const b = block('slider');
export const Slider = React.forwardRef(function Slider({ value, defaultValue = 0, size = 'm', min = 0, max = 100, step = 1, marksCount = 2, availableValues, hasTooltip = false, errorMessage, validationState, disabled = false, debounceDelay = 0, onBlur, onUpdate, onUpdateComplete, onFocus, autoFocus = false, tabIndex, className, qa, apiRef, 'aria-label': ariaLabelForHandle, 'aria-labelledby': ariaLabelledByForHandle, }, ref) {
    const direction = useDirection();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const handleUpdate = React.useCallback(debounce((changedValue) => onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(changedValue), debounceDelay), [onUpdate, debounceDelay]);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const handleUpdateComplete = React.useCallback(debounce((changedValue) => onUpdateComplete === null || onUpdateComplete === void 0 ? void 0 : onUpdateComplete(changedValue), debounceDelay), [onUpdateComplete, debounceDelay]);
    React.useEffect(() => {
        return () => {
            handleUpdate.cancel();
            handleUpdateComplete.cancel();
        };
    }, [handleUpdate, handleUpdateComplete]);
    const innerState = prepareSliderInnerState({
        availableValues,
        defaultValue,
        marksCount,
        max,
        min,
        step,
        value,
    });
    const stateModifiers = {
        size,
        error: validationState === 'invalid' && !disabled,
        disabled,
        hasTooltip: Boolean(hasTooltip),
        rtl: direction === 'rtl',
    };
    return (React.createElement("div", { className: b(null, className), ref: ref },
        React.createElement("div", { className: b('top', { size, hasTooltip }) }),
        React.createElement(BaseSlider, { ref: apiRef, value: innerState.value, defaultValue: innerState.defaultValue, min: innerState.min, max: innerState.max, step: innerState.step, range: innerState.range, disabled: disabled, marks: innerState.marks, onBlur: onBlur, onFocus: onFocus, onChange: handleUpdate, onChangeComplete: handleUpdateComplete, stateModifiers: stateModifiers, 
            // eslint-disable-next-line jsx-a11y/no-autofocus
            autoFocus: autoFocus, tabIndex: tabIndex, "data-qa": qa, handleRender: hasTooltip
                ? (originHandle, handleProps) => {
                    var _a;
                    const styleProp = stateModifiers.rtl ? 'right' : 'left';
                    return (React.createElement(React.Fragment, null,
                        originHandle,
                        React.createElement(SliderTooltip, { value: handleProps.value, className: b('tooltip'), style: {
                                insetInlineStart: (_a = originHandle.props.style) === null || _a === void 0 ? void 0 : _a[styleProp],
                            }, stateModifiers: stateModifiers })));
                }
                : undefined, reverse: stateModifiers.rtl, ariaLabelForHandle: ariaLabelForHandle, ariaLabelledByForHandle: ariaLabelledByForHandle }),
        stateModifiers.error && errorMessage && (React.createElement("div", { className: b('error', { size }) }, errorMessage))));
});
