"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareSliderInnerState = exports.getMarksFromInfoPoints = void 0;
const constants_1 = require("./constants");
function prepareSingleValue({ value, min, max }) {
    if (typeof value === 'undefined' || value < min) {
        return min;
    }
    else if (value > max) {
        return max;
    }
    return value;
}
function prepareArrayValue({ value = [], min = 0, max = 100, }) {
    return [
        prepareSingleValue({ max, min, value: value[0] }),
        prepareSingleValue({ max, min, value: value[1] }),
    ].sort((v1, v2) => v1 - v2);
}
function calculateInfoPoints({ count = 0, max, min }) {
    if (max === min) {
        return [min];
    }
    if (count > 2) {
        const points = [];
        const step = Math.abs(max - min) / (count - 1);
        for (let i = 0; i < count; i++) {
            points.push(Math.round((min + step * i) * 100) / 100);
        }
        return points;
    }
    return [min, max];
}
function getMarksFromInfoPoints({ infoPointsCount, max, min, }) {
    const marks = {
        [min]: { label: min, style: { left: 0, transform: 'translateX(0)' } },
        [max]: { label: max, style: { transform: 'translateX(-100%)' } },
    };
    if (infoPointsCount > 2) {
        const step = Math.abs(max - min) / (infoPointsCount - 1);
        if (step === 0) {
            marks[min] = min;
        }
        else {
            for (let i = 0; i < infoPointsCount; i++) {
                const point = Math.round((min + step * i) * 100) / 100;
                marks[point] = point;
            }
        }
    }
    return marks;
}
exports.getMarksFromInfoPoints = getMarksFromInfoPoints;
function createMarks(points) {
    const marks = {};
    const lastIndex = points.length - 1;
    points.forEach((point, i) => {
        if (i === 0) {
            marks[point] = { label: point, style: constants_1.CLEAR_MARK_STYLE };
        }
        else if (i === lastIndex) {
            marks[point] = { label: point, style: constants_1.CLEAR_MARK_STYLE };
        }
        else {
            marks[point] = point;
        }
    });
    return marks;
}
/**
 * Calculates the basic properties of the Slider component depending on the passed parameters
 * @returns {SliderInnerState} Properties to pass to the Slider
 */
function prepareSliderInnerState({ max = 100, min = 0, availableValues, defaultValue, marksCount, step, value, }) {
    const state = {
        value,
        defaultValue,
        range: false,
        max,
        min,
        marks: undefined,
        step,
    };
    if (max < min) {
        state.max = min;
        state.min = max;
    }
    if (availableValues && availableValues.length > 0) {
        //can select only available values
        state.step = null;
        const sortedAvailableValues = Array.from(new Set(availableValues)).sort((v1, v2) => v1 - v2);
        state.min = sortedAvailableValues[0];
        state.max = sortedAvailableValues[sortedAvailableValues.length - 1];
        state.marks = createMarks(sortedAvailableValues);
    }
    else {
        state.marks = createMarks(calculateInfoPoints({ count: marksCount, max, min }));
    }
    if (value === undefined) {
        const isArray = Array.isArray(defaultValue);
        state.range = isArray;
        state.defaultValue = isArray
            ? prepareArrayValue({
                min: state.min,
                max: state.max,
                value: defaultValue,
            })
            : prepareSingleValue({
                min: state.min,
                max: state.max,
                value: defaultValue,
            });
    }
    else {
        const isArray = Array.isArray(value);
        state.range = isArray;
        state.value = isArray
            ? prepareArrayValue({ min: state.min, max: state.max, value })
            : prepareSingleValue({ min: state.min, max: state.max, value });
    }
    return state;
}
exports.prepareSliderInnerState = prepareSliderInnerState;
